local sStartUpdateTime
local sFrameRate
local sUpdateMessageId
local sCellWidth
local sFoot1Loc
local sFoot2Loc
local sFoot3Loc
local sPivotLoc

local sFootPivotCount // Keep track of how many feet have moved in pivot move (animation happens asynchronously and AE only offers a single callback out of the box)

local sFootLanding1Locs // Array of the loc(s) that foot 1 needs to be at to win
local sFootLanding2Locs
local sFootLanding3Locs

local sLevelProperties

local sGameRunning
local sCheckingForWin

local sMovesCounter
local sTotalMoves

global gTouchStartLoc
global gScale
global gTouchedFoot

local sLastLevelCompleted

local sTime

local sJumpAnimateSpeed
local sPivotAnimateSpeed
local sCurrentAnimation // Pivot or jump
local sCollision

## Stack custom properties: 
// accelleratedRendering

on preOpenStack
   set the accelleratedRendering of this stack to true
   set the defaultFolder to specialFolderPath("documents") // Where we write files to (good for iOS and Mac OS X)
   start using stack "Helper"
   
   if the environment is mobile then 
      if iphoneDeviceScale() is "2" then // Returns 2 on a retina display, 1 otherwise
         put 2 into gScale
         iphoneUseDeviceResolution true, true // Sets whether the full resolution of high-resolution devices is to be used
      end if
   end if
   
end preOpenStack

on openStack
   
   if "animationEngine" is not among the lines of the stacksInUse then
      start using stack "animationEngine"
   end if
   
   if there is a file "moves.txt" then
      put URL ("file:moves.txt") into sTotalMoves // Get total moves used from file and store in script local
   else
      put 10000 into sTotalMoves // If no file, then put to 10000
   end if
   
   retrieveHighScores   
   
end openStack

on test
   
   // Get stack custom property sets
   put the customPropertySets of the current stack into tCustomPropertySets
   
   // Cycle through the array and format for saving to file
   repeat for each line tSet in the keys of tCustomPropertySets
      answer tSet
   end repeat
   
end test

on closeStack
   
   put sTotalMoves into URL ("file:moves.txt") // Store number of moves remaining   
   saveHighScores
   
end closeStack

on saveHighScores
   
   // Get high scores custom property as an array
   put the customProperties["cHighScores"] of the current stack into tHighScores
   
   // Cycle through the array and format for saving to file
   repeat for each line tKey in the keys of tHighScores
      put tKey & ":" & tHighScores[tKey] & return after tArrayContents
   end repeat
   
   put tArrayContents into URL ("file:highscores.txt") // Save to file
   
end saveHighScores

## Read high scores from file
on retrieveHighScores
   
   if there is a file "highscores.txt" then      
      put URL ("file:highscores.txt") into tHighScores // Get text file   
      split tHighScores by return and ":" // Split into array   
      set the customProperties["cHighScores"] of this stack to tHighScores // Set the array to value of cHighScores custom property
   end if   
   
end retrieveHighScores

## Level launch controller

on launchLevel
   
   configureLevelCard
   
   go cd "level"
   
   setupLevel
   startGame
   
end launchLevel

## Copies controls from relevant level template to the actual level card

on configureLevelCard
   
   put "level" & the cCurrentLevel of this stack into tCurrentLevel // Get level name   
   put the customProperties[tCurrentLevel] of this stack into tLevelProperties // Get level's custom properties
   put tLevelProperties into sLevelProperties // Make level properties available to whole script
   put tLevelProperties["cLevelTemplate"] into tTemplateName
   
   deleteControlsFromCard "level" // Delete any existing controls from the "level" card
   
   repeat with tControl = 1 to the number of controls in cd tLevelProperties["cLevelTemplate"] // Go through all controls in template card
      copy control tControl of card tTemplateName to card "level" // Copy them over to the level
   end repeat
   
   ## Populate src element buttons with images relevant to this level
   
   put tLevelProperties["cFootImageGrps"] into tFootImageGrps // Get image groups used for each foot
   split tFootImageGrps by return and ":" // Split into array
   
   repeat for each line tKey in the keys of tFootImageGrps
      put tFootImageGrps[tKey] & "@2x" into tFootImage // Concatenate foot image name
      put "foot" & tKey & "_src" into tButtonName // Concatenate button name      
      set the cAnim of btn tButtonName of cd "level" to the cAnim of grp tFootImageGrps[tKey] of the cd "elements" // Apply animation image list (from foot group custom properties) to the foot
      setControlIcon tButtonName, "level", tFootImage, "elements" // Set the icon
      
      put tFootImageGrps[tKey] & "_landing@2x" into tFootLandingImage // Concatenate foot landing image name
      put "landing" & tKey & "_src" into tButtonName // Concatenate button name
      setControlIcon tButtonName, "level", tFootLandingImage, "elements" // Set the icon
      
   end repeat
   
end configureLevelCard

## Level setup

on setupLevel
   
   put the width of btn "grid" / 8 into sCellWidth // Get width of each circular 'cell'
   put sCellWidth / 2 + the left of btn "grid" into tX // Work out starting point on X axis
   put sCellWidth / 2 + the top of btn "grid" into tY // And the Y
   
   put sLevelProperties["cElementPlacement"] into tElPlacement // Get placement grid
   
   repeat for each line l in tElPlacement -- Cycle through each line
      
      repeat for each item el in l -- Cycle through each cell
         
         ## Check button type
         if el is 4 then -- Block
            clone button "block_src"
            set the name of it to "block"
         else if el is 1 then -- Foot 1
            clone button "foot1_src"
            set the name of it to "foot1"
            set the class of it to "foot"
         else if el is 2 then -- Foot 2
            clone button "foot2_src"
            set the name of it to "foot2"
            set the class of it to "foot"
         else if el is 3 then -- Foot 3
            clone button "foot3_src"
            set the name of it to "foot3"
            set the class of it to "foot"
         else if el is 5 then -- Landing 1
            clone button "landing1_src"
            set the name of it to "landing1"
            set the class of it to "landing"
         else if el is 6 then -- Landing 2
            clone button "landing2_src"
            set the name of it to "landing2"
            set the class of it to "landing"
         else if el is 7 then -- Landing 3
            clone button "landing3_src"
            set the name of it to "landing3"
            set the class of it to "landing"
         else if el is 8 then -- Pivot
            clone button "pivot_src"
            set the name of it to "pivot"
            set the visible of it to false
         end if
         
         if el is not 0 then
            set the loc of the last button to tX,tY -- Place button on grid
         end if
         
         put tX + sCellWidth into tX -- Next cell
         
      end repeat 
      
      put sCellWidth / 2 + the left of button "grid" into tX -- Back to beginning of row
      put tY + sCellWidth into tY -- Next row
      
   end repeat   
   
   ## Clone other bits of UI
   
   // Bring sprite to top
   set the layer of btn "foot3" to top
   set the layer of btn "foot2" to top
   set the layer of btn "foot1" to top
   set the layer of btn "pivot" to top
   
   ## Store the starting positions of the feet
   
   put item 1 of the loc of btn "foot1" into sFoot1Loc["x"] // X
   put item 2 of the loc of btn "foot1" into sFoot1Loc["y"] // Y
   
   put item 1 of the loc of btn "foot2" into sFoot2Loc["x"]
   put item 2 of the loc of btn "foot2" into sFoot2Loc["y"]
   
   put item 1 of the loc of btn "foot3" into sFoot3Loc["x"]
   put item 2 of the loc of btn "foot3" into sFoot3Loc["y"]   
   
   ## Store pivot position
   
   put the loc of btn "pivot" into sPivotLoc
   
   ## Set various level values
   
   put false into sChangeInFootPos
   put 500 into sJumpAnimateSpeed // Speed in ms jump
   put 230 into sPivotAnimateSpeed // Speed in ms jump
   put 0 into sMovesCounter // Reset move counter
   put false into sCollision // Set collision flag to false
   put empty into sFootLandingLocs // Empty target foot location array
   set the label of button "moves_value" to sMovesCounter // Amend moves counter
   put false into sCheckingForWin // Prevents further moves while code checks to see whether use has positioned feet at the target locations
   put empty into sCurrentAnimation
   put empty into sTouchStartLoc
   put empty into gTouchStartLoc
   
   // Clear landing location arrays
   put empty into sFootLanding1Locs
   put empty into sFootLanding2Locs
   put empty into sFootLanding3Locs
   
   ## Calculate landing locs
   
   // Get the icon ID of each foot
   put the icon of btn "foot1" into tFoot1Icon
   put the icon of btn "foot2" into tFoot2Icon
   put the icon of btn "foot3" into tFoot3Icon
   
   // Get the locs of the three landing spots
   put the loc of btn "landing1" into tLanding1Loc
   put the loc of btn "landing2" into tLanding2Loc
   put the loc of btn "landing3" into tLanding3Loc
   
   if tFoot1Icon is tFoot2Icon and tFoot1Icon is tFoot3Icon then // If all feet use the same icon      
      
      // Create temp array
      put tLanding1Loc into tArray[1]
      put tLanding2Loc into tArray[2]
      put tLanding3Loc into tArray[3]
      
      // Put the array into the landing locs array
      put tArray into sFootLanding1Locs
      put tArray into sFootLanding2Locs
      put tArray into sFootLanding3Locs
      
   else if tFoot1Icon is tFoot2Icon and tFoot1Icon is not tFoot3Icon then // If feet 1 and 2 are the same
      
      put tLanding1Loc into tArray[1]
      put tLanding2Loc into tArray[2]
      
      put tArray into sFootLanding1Locs
      put tArray into sFootLanding2Locs
      
      put tLanding3Loc into sFootLanding3Locs[1]
      
   else if tFoot2Icon is tFoot3Icon and tFoot1Icon is not tFoot3Icon then // If feet 2 and 3 are the same
      
      put tLanding2Loc into tArray[1]
      put tLanding3Loc into tArray[2]
      
      put tArray into sFootLanding2Locs
      put tArray into sFootLanding3Locs
      
      put tLanding1Loc into sFootLanding1Locs[1]
      
   else // If all feet have different icons
      
      put tLanding1Loc into sFootLanding1Locs[1]
      put tLanding2Loc into sFootLanding2Locs[1]
      put tLanding3Loc into sFootLanding3Locs[1]
      
   end if
   
   set the label of button "number_moves_remaining" to sTotalMoves
   set the label of button "time_value" to 0
   
end setupLevel

// Hide the sprite

on hideSprite
   set the vis of button "foot1" to false
   set the vis of button "foot2" to false
   set the vis of button "foot3" to false
end hideSprite

// Flash the sprite

on aeWrapper pAEFunc, pMilliSecs
   
   if pAEFunc is "fadeIn" then
      aeLockMoves
      aeFadeIn the long id of btn "foot1",pMilliSecs
      aeFadeIn the long id of btn "foot2",pMilliSecs
      aeFadeIn the long id of btn "foot3",pMilliSecs
      aeUnlockMoves
   end if
   
   if pAEFunc is "fadeOut" then
      aeLockMoves
      aeFadeOut the long id of btn "foot1",pMilliSecs
      aeFadeOut the long id of btn "foot2",pMilliSecs
      aeFadeOut the long id of btn "foot3",pMilliSecs
      aeUnlockMoves
   end if
   
end aeWrapper

on flashSprite
   
   put 200 into flashSpeed
   
   // Flash pivot
   put the long ID of btn "pivot" into tPivot
   send "aefadeIn tPivot, flashSpeed" to me in 750 millisecs
   
   // Flash feet   
   send "aeWrapper fadeIn, flashSpeed" to me in 450 millisecs
   send "aeWrapper fadeIn, flashSpeed" to me in 750 millisecs
   
end flashSprite

on clearLevel
   
   // Delete level objects from card
   put the number of buttons of this card into tCount
   repeat with x = tCount down to 1
        if the class of button x of this card is "foot" or the class of button x of this card is "landing" or the class of button x of this card is "shadowFoot" or the short name of button x of this card is "block" or the short name of button x of this card is "pivot" then
             delete button x of this card
        end if
   end repeat
   
end clearLevel
   
on startGame
   
   flashSprite
   repositionPivot

   put true into sGameRunning   
   
   send "startTimer" to me in 500 millisecs
   
end startGame

on stopGame
   
   put false into sGameRunning
   
end stopGame

on startTimer
   
   put the seconds into sTime
   goTimer
   
end startTimer

on goTimer
   
   // Stop time when game stops running
   if not sGameRunning then
      exit to top
   end if
   
   set the label of btn "time_value" to 0 + (the seconds - sTime)
   send "goTimer" to me in 1 millisec
   
end goTimer

on incrMoves
   
   put sMovesCounter + 1 into sMovesCounter // sMovesCounter++
   set the label of button "moves_value" to sMovesCounter // Amend moves counter
   
   put sTotalMoves - 1 into sTotalMoves // sTotalMoves--
   set the label of button "number_moves_remaining" to sTotalMoves // Amend total moves counter
    
end incrMoves

on goJump pX, pY, pPivotX, pPivotY, pFootShortName
   
   put false into tBoundaryHit
   put the loc of button pFootShortName into tPreMoveFootPos
   
   set the layer of btn pFootShortName to top
   
   // Get coords of grid boundary
   put the top of button "grid" into tGridTop
   put the bottom of button "grid" into tGridBottom
   put the left of button "grid" into tGridLeft
   put the right of button "grid" into tGridRight
   
   if pY < tGridTop or pY > tGridBottom or pX < tGridLeft or pX > tGridRight then // If game area boundary will be hit
      
      put true into tBoundaryHit
      
      // Amend pX and pY parameters
      if pY < tGridTop then
         put tGridTop + (sCellWidth / 2) into pY
      else if pY > tGridBottom then
         put tGridBottom - (sCellWidth / 2) into pY
      else if pX > tGridRight then
         put tGridRight - (sCellWidth / 2) into pX
      else if pX < tGridLeft then
         put tGridLeft + (sCellWidth / 2) into pX
      end if
      
   end if  
   
   put "overshoot" into tJumpEffect // Default jump easing effect
   
   put item 1 of tPreMoveFootPos into tFootPrevX // Get X coord of previous foot loc
   put item 2 of tPreMoveFootPos into tFootPrevY // Get Y coord of previous foot loc
   
   if tBoundaryHit then // If a boundary has been hit
      
      put "bounce" into tEffect      
      
      // Get mid-point between other two feet
      if pFootShortName is "foot1" then
         put getMidPoint(the loc of btn "foot2", the loc of btn "foot3") into tMidPoint
      else if pFootShortName is "foot2" then
         put getMidPoint(the loc of btn "foot1", the loc of btn "foot3") into tMidPoint
      else if pFootShortName is "foot3" then
         put getMidPoint(the loc of btn "foot1", the loc of btn "foot2") into tMidPoint
      end if
      
      send "hidePivot 100" to me in 1 millisecs // Fade out pivot
  
      aeMoveTo the long id of btn pFootShortName, item 1 of tMidPoint, item 2 of tMidPoint, sJumpAnimateSpeed / 3.5, "" // Move to boundary
      send "jumpBack pFootShortName, tFootPrevX, tFootPrevY, tEffect" to btn pFootShortName in 200 milliseconds // Jump back after wait
      send "showPivot 150" to me in 300 millisecs // Fade pivot back in
            
   else // Otherwise, move to new position
      
      send "hidePivot 100" to me in 1 millisecs // Fade out pivot
            
      animateFoot pFootShortName
      
      aeLockMoves
      aeMoveTo the long id of btn pFootShortName,pX,pY,sJumpAnimateSpeed,tJumpEffect
      aeUnlockMoves
           
   end if
   
   // Detect collision with block
   set the loc of btn "shadowFoot1" to pX,pY // Set position of a shadow foot to check for imminent collisions  
   put detectCollision() into tJumpCollide
   
   if tJumpCollide and not tBoundaryHit then // If the foot will jump onto a block
      put "jumpFail" into sCurrentAnimation
      put "overshoot" into tEffect
      send "jumpBack pFootShortName, tFootPrevX, tFootPrevY, tEffect" to btn pFootShortName in 700 milliseconds // Call jumpBack() after a short interval
      send "showPivot 150" to me in 1000 millisecs // Fade pivot back in
   end if
   
   if not tBoundaryHit and not tJumpCollide then // If a boundary hasn't been hit, or the foot hasn't jumped onto a block
      
      send "showPivot 150" to me in sJumpAnimateSpeed millisecs
      
      send "incrMoves" to this card in sJumpAnimateSpeed milliseconds // Increment moves counter

      if pFootShortName is "foot1" then // Update script-level loc for relevant foot
         put pX into sFoot1Loc["x"]
         put pY into sFoot1Loc["y"]
      else if pFootShortName is "foot2" then
         put pX into sFoot2Loc["x"]
         put pY into sFoot2Loc["y"]
      else if pFootShortName is "foot3" then
         put pX into sFoot3Loc["x"]
         put pY into sFoot3Loc["y"]
      end if
   end if
   
end goJump

## Fades out pivot

on hidePivot pSpeed
   
   put the long ID of btn "pivot" into tPivot      
   aeFadeOut tPivot, pSpeed
   
end hidePivot

## Fades in pivot and puts to top layer

on showPivot pSpeed
   
   put the long ID of btn "pivot" into tPivot   
   set the layer of tPivot to top
   aeFadeIn tPivot, pSpeed
   
end showPivot

## Animates lift and drop of foot

on goAnimate pFootShortName, imageID
   set the icon of btn pFootShortName to imageID
end goAnimate

## Control animation for lift and drop of foot

on animateFoot pFootShortName
   
   put the imgGrp of btn pFootShortName into tImgGrpID // Get the ID of the image group which corresponds with this foot
   put the cAnim of btn pFootShortName into tAnimImages // Get the anim custom property of the group (in the "elements" card). This lists the images which will be used in the animation
   
   put round(sJumpAnimateSpeed / 12) into tAnimInc // Calculate a 'frame rate'
   put 1 into tMultiplier // So animation frames change at right moment
   
   // Do the animation
   repeat for each line tImgID in tAnimImages
      send "goAnimate pFootShortName, tImgID" to btn pFootShortName in tAnimInc * tMultiplier milliseconds
      put tMultiplier + 1 into tMultiplier
   end repeat
   
end animateFoot

on repositionPivot
   
   // Get angles of foot one to other two feet
   put the loc of btn "foot1" into tFoot1
   put the loc of btn "foot2" into tFoot2
   put the loc of btn "foot3" into tFoot3
   
   put getAngleBetweenPoints(tFoot1, tFoot2) into tAngle12
   put getAngleBetweenPoints(tFoot1, tFoot3) into tAngle13
   
   put round(sCellWidth / 6) into tPivotShift // The pivot will be moved by slightly more than the cell width
   
   ## For clockwise arrangement 1, 2, 3
   
   if tAngle12 is 63 and tAngle13 is 117 then // Position 1
      put item 1 of tFoot1 into tPivotX
      put item 2 of tFoot1 + sCellWidth + tPivotShift into tPivotY
      
   else if tAngle12 is 90 and tAngle13 is 153 then // Position 2
      put item 2 of tFoot3 into tPivotY
      put item 1 of tFoot3 + sCellWidth + tPivotShift into tPivotX
      
   else if tAngle12 is 117 and tAngle13 is 180 then // Position 3
      put item 1 of tFoot2 into tPivotX
      put item 2 of tFoot2 - sCellWidth - tPivotShift into tPivotY
      
   else if tAngle12 is 153 and tAngle13 is -153 then // Position 4
      put item 2 of tFoot1 into tPivotY
      put item 1 of tFoot1 - sCellWidth - tPivotShift into tPivotX
      
   else if tAngle12 is 180 and tAngle13 is -117 then // Position 5
      put item 1 of tFoot3 into tPivotX
      put item 2 of tFoot3 + sCellWidth + tPivotShift into tPivotY
      
   else if tAngle12 is -153 and tAngle13 is -90 then // Position 6
      put item 2 of tFoot2 into tPivotY
      put item 1 of tFoot2 + sCellWidth + tPivotShift into tPivotX
      
   else if tAngle12 is -117 and tAngle13 is -63 then // Position 7
      put item 1 of tFoot1 into tPivotX
      put item 2 of tFoot1 - sCellWidth - tPivotShift into tPivotY
      
   else if tAngle12 is -90 and tAngle13 is -27 then // Position 8
      put item 2 of tFoot3 into tPivotY
      put item 1 of tFoot3 - sCellWidth - tPivotShift into tPivotX
      
   else if tAngle12 is -63 and tAngle13 is 0 then // Position 9
      put item 1 of tFoot2 into tPivotX
      put item 2 of tFoot2 + sCellWidth + tPivotShift into tPivotY
      
   else if tAngle12 is -27 and tAngle13 is 27 then // Position 10
      put item 2 of tFoot1 into tPivotY
      put item 1 of tFoot1 + sCellWidth + tPivotShift into tPivotX
      
   else if tAngle12 is 0 and tAngle13 is 63 then // Position 11
      put item 1 of tFoot3 into tPivotX
      put item 2 of tFoot3 - sCellWidth - tPivotShift into tPivotY
      
   else if tAngle12 is 27 and tAngle13 is 90 then // Position 12
      put item 2 of tFoot2 into tPivotY
      put item 1 of tFoot2 - sCellWidth - tPivotShift into tPivotX
      
   else if tAngle13 is 63 and tAngle12 is 117 then // Position 1 (clockwise 1, 3, 2)         
      put item 1 of tFoot1 into tPivotX
      put item 2 of tFoot1 + sCellWidth + tPivotShift into tPivotY
      
   else if tAngle13 is 90 and tAngle12 is 153 then // Position 2
      put item 2 of tFoot2 into tPivotY
      put item 1 of tFoot2 + sCellWidth + tPivotShift into tPivotX
      
   else if tAngle13 is 117 and tAngle12 is 180 then // Position 3
      put item 1 of tFoot3 into tPivotX
      put item 2 of tFoot3 - sCellWidth - tPivotShift into tPivotY
      
   else if tAngle13 is 153 and tAngle12 is -153 then // Position 4
      put item 2 of tFoot1 into tPivotY
      put item 1 of tFoot1 - sCellWidth - tPivotShift into tPivotX
      
   else if tAngle13 is 180 and tAngle12 is -117 then // Position 5
      put item 1 of tFoot2 into tPivotX
      put item 2 of tFoot2 + sCellWidth + tPivotShift into tPivotY
      
   else if tAngle13 is -153 and tAngle12 is -90 then // Position 6
      put item 2 of tFoot3 into tPivotY
      put item 1 of tFoot3 + sCellWidth + tPivotShift into tPivotX
      
   else if tAngle13 is -117 and tAngle12 is -63 then // Position 7
      put item 1 of tFoot1 into tPivotX
      put item 2 of tFoot1 - sCellWidth - tPivotShift into tPivotY
      
   else if tAngle13 is -90 and tAngle12 is -27 then // Position 8
      put item 2 of tFoot2 into tPivotY
      put item 1 of tFoot2 - sCellWidth - tPivotShift into tPivotX
      
   else if tAngle13 is -63 and tAngle12 is 0 then // Position 9
      put item 1 of tFoot3 into tPivotX
      put item 2 of tFoot3 + sCellWidth + tPivotShift into tPivotY
      
   else if tAngle13 is -27 and tAngle12 is 27 then // Position 10
      put item 2 of tFoot1 into tPivotY
      put item 1 of tFoot1 + sCellWidth + tPivotShift into tPivotX
      
   else if tAngle13 is 0 and tAngle12 is 63 then // Position 11
      put item 1 of tFoot2 into tPivotX
      put item 2 of tFoot2 - sCellWidth - tPivotShift into tPivotY
      
   else if tAngle13 is 27 and tAngle12 is 90 then // Position 12
      put item 2 of tFoot3 into tPivotY
      put item 1 of tFoot3 - sCellWidth - tPivotShift into tPivotX
   else
      // Just a bit of defensive programming for the pivot to stay still if none of the above conditions is met (so tPivotX and tPivotY have a value) 
      put item 1 of the loc of btn "pivot" into tPivotX
      put item 2 of the loc of btn "pivot" into tPivotY
   end if
   
   put tPivotX,tPivotY into sPivotLoc
   
   if the loc of btn "pivot" is not sPivotLoc and sCurrentAnimation is "pivot" then // If the pivot needs to change location after a pivot move
      put the long ID of btn "pivot" into tPivot
      send "aeMoveTo tPivot, item 1 of sPivotLoc, item 2 of sPivotLoc, 200" to me in 1 millisecs
   else if the loc of btn "pivot" is not sPivotLoc and sCurrentAnimation is "jump" then // If the pivot needs to change location after a jump
      set the loc of btn "pivot" to sPivotLoc // Set new loc right away
   else if not sGameRunning then // On card load, before game is running
      set the loc of btn "pivot" to sPivotLoc  
   end if
   
end repositionPivot
   
on jump pFootLoc, pFootShortName

   if not sCheckingForWin and not isAnimating() then

      resetShowFeet
      
      put "jump" into sCurrentAnimation
      
      put 1 into tFootCount
      // Cycle through all feet
      
      repeat with tControl = 1 to the number of controls in current card // Go through all card controls

         if the class of control tControl is "foot" then // If the control is a foot
            
            put "foot" & tFootCount into tFoot
            put the loc of button tFoot into tFootLoc // Get the location of this foot
            
            if tFootLoc is not pFootLoc then // If this isn't the foot we've swiped
               put tFootLoc into tOtherFeetLocs[tFootCount] // Store the coordinates of this foot
            end if
            
            put tFootCount + 1 into tFootCount
         end if
         
      end repeat

      put 1 into tCount
      repeat for each element tElement in tOtherFeetLocs // For each of the other two foot locations
         put getAngleBetweenPoints(pFootLoc, tElement) into tAngles[tCount] // Get the angle between the swiped foot and the location of the other foot
         put tCount + 1 into tCount
      end repeat
      
      put item 1 of the loc of button pFootShortName into tX // Get current x pos of the swiped foot
      put item 2 of the loc of button pFootShortName into tY // Get current y pos of the swiped foot
      put item 1 of the loc of button "pivot" into tPivotX // Get current x pos of the pivot
      put item 2 of the loc of button "pivot" into tPivotY // Get current y pos of the pivot      
      
      // Read angles and work out in which direct the foot needs to jump
      if tAngles[1] is -117 and tAngles[2] is -63 or tAngles[2] is -117 and tAngles[1] is -63 then // N    
         put tY - (sCellWidth * 4) into tY // Amend the y pos of swiped foot
         //put tPivotY - (sCellWidth * 2) into tPivotY // Amend the y pos of pivot
      else if tAngles[1] is -27 and tAngles[2] is 27 or tAngles[2] is -27 and tAngles[1] is 27 then // E
         put tX + (sCellWidth * 4) into tX
         //put tPivotX + (sCellWidth * 2) into tPivotX
      else if tAngles[1] is 117 and tAngles[2] is 63 or tAngles[2] is 117 and tAngles[1] is 63 then // S      
         put tY + (sCellWidth * 4) into tY 
         //put tPivotY + (sCellWidth * 2) into tPivotY
      else if tAngles[1] is -153 and tAngles[2] is 153 or tAngles[2] is -153 and tAngles[1] is 153 then // W
         put tX - (sCellWidth * 4) into tX 
         //put tPivotX - (sCellWidth * 2) into tPivotX
      else if tAngles[1] is -117 and tAngles[2] is 180 or tAngles[2] is -117 and tAngles[1] is 180 then // NW
         put tY - (sCellWidth * 2) into tY
         put tX - (sCellWidth * 3) into tX
         //put tPivotX - sCellWidth into tPivotX
      else if tAngles[1] is -153 and tAngles[2] is -90 or tAngles[2] is -153 and tAngles[1] is -90 then // NNW    
         put tY - (sCellWidth * 3) into tY
         put tX - (sCellWidth * 2) into tX
         //put tPivotY - sCellWidth into tPivotY
      else if tAngles[1] is 0 and tAngles[2] is -63 or tAngles[2] is 0 and tAngles[1] is -63 then // NE
         put tY - (sCellWidth * 2) into tY
         put tX + (sCellWidth * 3) into tX
         //put tPivotX + sCellWidth into tPivotX
      else if tAngles[1] is -90 and tAngles[2] is -27 or tAngles[2] is -90 and tAngles[1] is -27 then // NNE    
         put tY - (sCellWidth * 3) into tY
         put tX + (sCellWidth * 2) into tX
         //put tPivotY - sCellWidth into tPivotY
      else if tAngles[1] is 0 and tAngles[2] is 63 or tAngles[2] is 0 and tAngles[1] is 63 then // SE
         put tY + (sCellWidth * 2) into tY
         put tX + (sCellWidth * 3) into tX
         //put tPivotX + sCellWidth into tPivotX
      else if tAngles[1] is 90 and tAngles[2] is 27 or tAngles[2] is 90 and tAngles[1] is 27 then // SSE    
         put tY + (sCellWidth * 3) into tY
         put tX + (sCellWidth * 2) into tX
         //put tPivotY + sCellWidth into tPivotY
      else if tAngles[1] is 117 and tAngles[2] is 180 or tAngles[2] is 117 and tAngles[1] is 180 then // SW    
         put tY + (sCellWidth * 2) into tY
         put tX - (sCellWidth * 3) into tX
         //put tPivotX - sCellWidth into tPivotX
      else if tAngles[1] is 153 and tAngles[2] is 90 or tAngles[2] is 153 and tAngles[1] is 90 then // SSW    
         put tY + (sCellWidth * 3) into tY
         put tX - (sCellWidth * 2) into tX
         //put tPivotY + sCellWidth into tPivotY
      end if
      
      goJump tX, tY, tPivotX, tPivotY, pFootShortName // Do the jump, passing in the new x and y coords of the swiped foot and pivot, and the foot name
   end if
end jump

on resetShowFeet
   set the loc of btn "shadowFoot1" to 0,0
   set the loc of btn "shadowFoot2" to 0,0
   set the loc of btn "shadowFoot3" to 0,0
end resetShowFeet

on pivot
   if not sCheckingForWin and not isAnimating() then // If no element is currently being animated, and we're not checking for a win
      
      resetShowFeet
      
      put "pivot" into sCurrentAnimation
      
      put the loc of btn "foot1" into tLastStationaryPos1
      put the loc of btn "foot2" into tLastStationaryPos2
      put the loc of btn "foot3" into tLastStationaryPos3
      
      split tLastStationaryPos1 by ","
      split tLastStationaryPos2 by ","
      split tLastStationaryPos3 by ","     
      
      put getAngleBetweenPoints(the loc of button "foot1", the loc of button "foot2") into tAngle12
      put getAngleBetweenPoints(the loc of button "foot1", the loc of button "foot3") into tAngle13
      
      ## For clockwise arrangement 1, 2, 3
      
      if tAngle12 is 63 and tAngle13 is 117 then // Position 1
         put sFoot1Loc["x"] + sCellWidth into sFoot1Loc["x"] // Move foot 1 to the right
         put sFoot3Loc["y"] - sCellWidth into sFoot3Loc["y"] // Move foot 3 up
         
      else if tAngle12 is 90 and tAngle13 is 153 then // Position 2
         put sFoot2Loc["x"] - sCellWidth into sFoot2Loc["x"] // Foot 2 left
         put sFoot3Loc["y"] - sCellWidth into sFoot3Loc["y"] // Foot 3 up 
         
      else if tAngle12 is 117 and tAngle13 is 180 then // Position 3
         put sFoot2Loc["x"] - sCellWidth into sFoot2Loc["x"] // Foot 2 left
         put sFoot1Loc["y"] + sCellWidth into sFoot1Loc["y"] // Foot 1 down 
         
      else if tAngle12 is 153 and tAngle13 is -153 then // Position 4
         put sFoot3Loc["x"] + sCellWidth into sFoot3Loc["x"] // Foot 3 right
         put sFoot1Loc["y"] + sCellWidth into sFoot1Loc["y"] // Foot 1 down
         
      else if tAngle12 is 180 and tAngle13 is -117 then // Position 5
         put sFoot3Loc["x"] + sCellWidth into sFoot3Loc["x"] // Foot 3 right
         put sFoot2Loc["y"] - sCellWidth into sFoot2Loc["y"] // Foot 2 up
         
      else if tAngle12 is -153 and tAngle13 is -90 then // Position 6
         put sFoot1Loc["x"] - sCellWidth into sFoot1Loc["x"] // Foot 1 left
         put sFoot2Loc["y"] - sCellWidth into sFoot2Loc["y"] // Foot 2 up
         
      else if tAngle12 is -117 and tAngle13 is -63 then // Position 7
         put sFoot1Loc["x"] - sCellWidth into sFoot1Loc["x"] // Foot 1 left
         put sFoot3Loc["y"] + sCellWidth into sFoot3Loc["y"] // Foot 3 down
         
      else if tAngle12 is -90 and tAngle13 is -27 then // Position 8
         put sFoot2Loc["x"] + sCellWidth into sFoot2Loc["x"] // Foot 2 right
         put sFoot3Loc["y"] + sCellWidth into sFoot3Loc["y"] // Foot 3 down
         
      else if tAngle12 is -63 and tAngle13 is 0 then // Position 9
         put sFoot2Loc["x"] + sCellWidth into sFoot2Loc["x"] // Foot 2 right
         put sFoot1Loc["y"] - sCellWidth into sFoot1Loc["y"] // Foot 1 up
         
      else if tAngle12 is -27 and tAngle13 is 27 then // Position 10
         put sFoot3Loc["x"] - sCellWidth into sFoot3Loc["x"] // Foot 3 left
         put sFoot1Loc["y"] - sCellWidth into sFoot1Loc["y"] // Foot 1 up
         
      else if tAngle12 is 0 and tAngle13 is 63 then // Position 11
         put sFoot3Loc["x"] - sCellWidth into sFoot3Loc["x"] // Foot 3 left
         put sFoot2Loc["y"] + sCellWidth into sFoot2Loc["y"] // Foot 2 down
         
      else if tAngle12 is 27 and tAngle13 is 90 then // Position 12
         put sFoot1Loc["x"] + sCellWidth into sFoot1Loc["x"] // Foot 1 right
         put sFoot2Loc["y"] + sCellWidth into sFoot2Loc["y"] // Foot 2 down        
         
      else if tAngle13 is 63 and tAngle12 is 117 then // Position 1 (clockwise 1, 3, 2)
         put sFoot1Loc["x"] + sCellWidth into sFoot1Loc["x"] // Move foot 1 to the right
         put sFoot2Loc["y"] - sCellWidth into sFoot2Loc["y"] // Move foot 2 up     
         
      else if tAngle13 is 90 and tAngle12 is 153 then // Position 2
         put sFoot3Loc["x"] - sCellWidth into sFoot3Loc["x"] // Foot 3 left
         put sFoot2Loc["y"] - sCellWidth into sFoot2Loc["y"] // Foot 2 up
         
      else if tAngle13 is 117 and tAngle12 is 180 then // Position 3
         put sFoot3Loc["x"] - sCellWidth into sFoot3Loc["x"] // Foot 3 left
         put sFoot1Loc["y"] + sCellWidth into sFoot1Loc["y"] // Foot 1 down 
         
      else if tAngle13 is 153 and tAngle12 is -153 then // Position 4
         put sFoot2Loc["x"] + sCellWidth into sFoot2Loc["x"] // Foot 2 right
         put sFoot1Loc["y"] + sCellWidth into sFoot1Loc["y"] // Foot 1 down
         
      else if tAngle13 is 180 and tAngle12 is -117 then // Position 5
         put sFoot2Loc["x"] + sCellWidth into sFoot2Loc["x"] // Foot 2 right
         put sFoot3Loc["y"] - sCellWidth into sFoot3Loc["y"] // Foot 3 up
         
      else if tAngle13 is -153 and tAngle12 is -90 then // Position 6
         put sFoot1Loc["x"] - sCellWidth into sFoot1Loc["x"] // Foot 1 left
         put sFoot3Loc["y"] - sCellWidth into sFoot3Loc["y"] // Foot 3 up
         
      else if tAngle13 is -117 and tAngle12 is -63 then // Position 7
         put sFoot1Loc["x"] - sCellWidth into sFoot1Loc["x"] // Foot 1 left
         put sFoot2Loc["y"] + sCellWidth into sFoot2Loc["y"] // Foot 2 down
         
      else if tAngle13 is -90 and tAngle12 is -27 then // Position 8
         put sFoot3Loc["x"] + sCellWidth into sFoot3Loc["x"] // Foot 3 right
         put sFoot2Loc["y"] + sCellWidth into sFoot2Loc["y"] // Foot 2 down
         
      else if tAngle13 is -63 and tAngle12 is 0 then // Position 9
         put sFoot3Loc["x"] + sCellWidth into sFoot3Loc["x"] // Foot 3 right
         put sFoot1Loc["y"] - sCellWidth into sFoot1Loc["y"] // Foot 1 up
         
      else if tAngle13 is -27 and tAngle12 is 27 then // Position 10
         put sFoot2Loc["x"] - sCellWidth into sFoot2Loc["x"] // Foot 2 left
         put sFoot1Loc["y"] - sCellWidth into sFoot1Loc["y"] // Foot 1 up
         
      else if tAngle13 is 0 and tAngle12 is 63 then // Position 11
         put sFoot2Loc["x"] - sCellWidth into sFoot2Loc["x"] // Foot 2 left
         put sFoot3Loc["y"] + sCellWidth into sFoot3Loc["y"] // Foot 3 down
         
      else if tAngle13 is 27 and tAngle12 is 90 then // Position 12
         put sFoot1Loc["x"] + sCellWidth into sFoot1Loc["x"] // Foot 1 right
         put sFoot3Loc["y"] + sCellWidth into sFoot3Loc["y"] // Foot 3 down
         
      end if
      
      // Move feet
      put sFoot1Loc["x"] into tFoot1x
      put sFoot1Loc["y"] into tFoot1y
      set the loc of btn "shadowFoot1" to tFoot1x,tFoot1y // Set shadow foot to check for imminent collisions
      
      put sFoot2Loc["x"] into tFoot2x
      put sFoot2Loc["y"] into tFoot2y
      set the loc of btn "shadowFoot2" to tFoot2x,tFoot2y
      
      put sFoot3Loc["x"] into tFoot3x
      put sFoot3Loc["y"] into tFoot3y
      set the loc of btn "shadowFoot3" to tFoot3x,tFoot3y     
      
      if detectCollision() then // If collision
         
         // Put back values of feet positions - we won't be pivoting
         put item 1 of the loc of btn "foot1" into sFoot1Loc["x"]
         put item 2 of the loc of btn "foot1" into sFoot1Loc["y"]
         put item 1 of the loc of btn "foot2" into sFoot2Loc["x"]
         put item 2 of the loc of btn "foot2" into sFoot2Loc["y"]
         put item 1 of the loc of btn "foot3" into sFoot3Loc["x"]
         put item 2 of the loc of btn "foot3" into sFoot3Loc["y"]
         
         // Nudge feet
         nudge "foot1", tFoot1x, tFoot1y, sFoot1Loc["x"], sFoot1Loc["y"]
         nudge "foot2", tFoot2x, tFoot2y, sFoot2Loc["x"], sFoot2Loc["y"]
         nudge "foot3", tFoot3x, tFoot3y, sFoot3Loc["x"], sFoot3Loc["y"]
         
      else if the visible of btn "pivot" then // If no collision and pivot is visible, we can go ahead and pivot
         
         put 0 into sFootPivotCount // Register than no feet have yet moved
         put the long ID of btn "pivot" into tPivot

         aeLockMoves
         aeMoveTo the long id of btn "foot1",tFoot1x,tFoot1y,sPivotAnimateSpeed,"overshoot"
         aeMoveTo the long id of btn "foot2",tFoot2x,tFoot2y,sPivotAnimateSpeed,"overshoot"
         aeMoveTo the long id of btn "foot3",tFoot3x,tFoot3y,sPivotAnimateSpeed,"overshoot"
         aeUnlockMoves
         
         send "incrMoves" to this card in sPivotAnimateSpeed milliseconds // Increment moves counter
         
      end if
      
   end if
   
end pivot

## Called by AE on completion of animation

on aeMoveDone
   
   if sCurrentAnimation is "pivot" and sFootPivotCount < 2 then // If we're pivoting but all three feet have not yet be repositioned
      
      put sFootPivotCount + 1 into sFootPivotCount // Increment foot count
      
   else if sCurrentAnimation is "pivot" and sFootPivotCount is 2 then // If the pivot is complete
      
      repositionPivot
      checkWin
      
   else if sCurrentAnimation is "jump" then // If we've just completed a jump
      
      repositionPivot      
      checkWin
      
   end if
   
end aeMoveDone

function detectCollision 
   put false into tCollide
   repeat with tControl = 1 to the number of controls of current card // Cycle through card's controls
      if the short name of control tControl is "block" then // If this one's a block
         put the loc of control tControl into tBlockLoc // Get its location
         if tBlockLoc is the loc of btn "shadowFoot1" or tBlockLoc is the loc of btn "shadowFoot2" or tBlockLoc is the loc of btn "shadowFoot3" then // If the loc matches one of the shadow feet
            put true into tCollide // There has been a collision
            exit repeat
         end if
      end if
   end repeat
   
   return tCollide
end detectCollision

// Nudges feet on disallowed pivot attempt
on nudge pFoot, pFootX, pFootY, pFootCurrPosX, pFootCurrPosY // Foot, attempted X, attempted Y, pre-nudge X, pre-nudge Y
   
   put round(sCellWidth / 10) into nudgeAmount
   
   if item 1 of the loc of btn pFoot < pFootX then
      move btn pFoot to pFootCurrPosX + nudgeAmount, pFootCurrPosY in 50 milliseconds without waiting // Nudge right
   else if item 1 of the loc of btn pFoot > pFootX then
      move btn pFoot to pFootCurrPosX - nudgeAmount, pFootCurrPosY in 50 milliseconds without waiting // Nudge left
   else if item 2 of the loc of btn pFoot < pFootY then
      move btn pFoot to pFootCurrPosX, pFootCurrPosY + nudgeAmount in 50 milliseconds without waiting // Nudge down
   else if item 2 of the loc of btn pFoot > pFootY then
      move btn pFoot to pFootCurrPosX, pFootCurrPosY - nudgeAmount in 50 milliseconds without waiting // Nudge up
   end if
   
   send "nudgeBack pFoot, pFootCurrPosX, pFootCurrPosY" to btn pFoot in 275 milliseconds // Call nudgeBack() after a short interval
end nudge

// Nudges feet back to original position after disallowed pivot attempt
on nudgeBack pTarget,pX,pY,pTime
   move btn pTarget to pX,pY in 50 milliseconds without waiting
end nudgeBack

on jumpBack pTarget,pX,pY,pEffect
   aeMoveTo the long id of btn pTarget,pX,pY,sJumpAnimateSpeed,pEffect
end jumpBack

## Check whether feet have landed correctly on respective landing locations

on checkWin
   
   if sGameRunning and not sCheckingForWin and not isAnimating() then
      
      put true into sCheckingForWin // Flag that we're checking for a win
      
      // Reset check for feet landing correctly
      put false into tFoot1LandSuccess
      put false into tFoot2LandSuccess
      put false into tFoot3LandSuccess
      
      // Foot 1       
      repeat for each element tLoc in sFootLanding1Locs // Get the locs at which foot is able to land for level to be won
         if item 1 of the loc of button "foot1" is item 1 of tLoc and item 2 of the loc of button "foot1" is item 2 of tLoc then // If the X and Y coords of the foot match one of the array items
            put true into tFoot1LandSuccess
         end if
      end repeat
      
      // Foot 2       
      repeat for each element tLoc in sFootLanding2Locs 
         if item 1 of the loc of button "foot2" is item 1 of tLoc and item 2 of the loc of button "foot2" is item 2 of tLoc then
            put true into tFoot2LandSuccess
         end if
      end repeat
      
      // Foot 3   
      repeat for each element tLoc in sFootLanding3Locs 
         if item 1 of the loc of button "foot3" is item 1 of tLoc and item 2 of the loc of button "foot3" is item 2 of tLoc then
            put true into tFoot3LandSuccess
         end if
      end repeat
      
      if tFoot1LandSuccess and tFoot2LandSuccess and tFoot3LandSuccess then // If all feet are in the right locations
         levelWin // Run the level win routine
      else
         put false into sCheckingForWin // Flag that we're no longer checking for a win
      end if
      
   end if
   
end checkWin

on levelWin
   
   stopGame   
   flashSprite   
   
   put "You've won the level!" into tWinMsg
   
   ## Check for high score
   
   put false into tNewHighScore
   
   put "level" & the cCurrentLevel of this stack into tLevelName // Get level name
   put the cHighScores[tLevelName] of this stack into tCurrentHighScore // Get previous high score
   
   if sMovesCounter < tCurrentHighScore then // If we've completed the level in fewer moves than our previous attempts
      put true into tNewHighScore // Flag that this is a new high score
   end if
   
   if tNewHighScore then // If it's a new high score
      set the cHighScores[tLevelName] of this stack to sMovesCounter // Set the high score for this level to current value of moves counter
      put "You have also achieved a new personal best for this level of " & sMovesCounter & " moves!" into tNewHighScoreMsg
   else 
      put empty into tNewHighScoreMsg
   end if
   
   set the cWinMsg of cd "level_win" to tWinMsg // Set the message custom property of the win card
   set the cNewHighScoreMsg of cd "level_win" to tNewHighScoreMsg // Set the new-high-score message of the win card
   send "showWinCard" to me in 1300 millisecs // Show card to tell user they've completed the level
   
   set the cStarRating of cd "level_win" to calculateStarRating() // Get and set star rating
   
   put the cCurrentLevel of this stack + 1 into tNextLevel // Increment level number
   
   if "level" & tNextLevel is among the lines of the customPropertySets of the current stack then // If the level exists
      set the cCurrentLevel of this stack to tNextLevel // Set the next level
   else
      set the cCurrentLevel of this stack to 1 // Else go back to level 1
   end if   
   
end levelWin

## Calculates the level's star rating based on the level set's cStarRating custom property

function calculateStarRating
   
   put sLevelProperties["cStarRating"] into tStarRating // Get star rating parameters for level
   split tStarRating by return and ":" // Split into array
   
   if sMovesCounter <= tStarRating[3] then
      return 3 // 3-star rating
   else if sMovesCounter > tStarRating[3] and sMovesCounter <= tStarRating[2] then
      return 2 // 2-star rating
   else
      return 1 // 1-star rating
   end if

end calculateStarRating

on showWinCard
   
   clearLevel // Remove onscreen game elements
   go card "level_win" // Go to the success card
   
end showWinCard

function isAnimating
   
   // If the foot is in a mid-transit location, switch on the animation flag
   if sFoot1Loc["x"] <> item 1 of the loc of button "foot1" or sFoot1Loc["y"] <> item 2 of the loc of button "foot1" or sFoot2Loc["x"] <> item 1 of the loc of button "foot2" or sFoot2Loc["y"] <> item 2 of the loc of button "foot2" or sFoot3Loc["x"] <> item 1 of the loc of button "foot3" or sFoot3Loc["y"] <> item 2 of the loc of button "foot3" then
      return true
   else
      return false
   end if
   
end isAnimating
