local sStartUpdateTime
local sUpdateMessageId
local sCellWidth
local sFoot1Loc
local sFoot2Loc
local sFoot3Loc
local sPivotLoc

local sFootPivotCount // Keep track of how many feet have moved in pivot move (animation happens asynchronously and AE only offers a single callback out of the box)

local sFootLanding1Locs // Array of the loc(s) that foot 1 needs to be at to win
local sFootLanding2Locs
local sFootLanding3Locs

local sLevelProperties
local sGameRunning
local sLevelWon

local sCheckingForWin

local sMovesCounter

global gTouchStartLoc
global gScale
global gTouchedFoot

local sLastSetFullyCompleted // Updated when cycling through sets so we know which the last fully complete set is

local sTime

local sJumpAnimateSpeed
local sPivotAnimateSpeed
local sCurrentAnimation // Pivot or jump
local sCollision

on preOpenStack
   
   set the accelleratedRendering of this stack to true
   set the defaultFolder to specialFolderPath("documents") // Where we write files to (good for iOS and Mac OS X)
   start using stack "Helper"
   
   if the environment is "mobile" then

      set the rect of this stack to the screenrect // Resize the stack
      
      if iphoneDeviceScale() is "2" then // Returns 2 on a retina display, 1 otherwise
         put 2 into gScale
         iphoneUseDeviceResolution true, true // Sets whether the full resolution of high-resolution devices is to be used
      end if
      
   end if
   
end preOpenStack

on openStack
   
   if "animationEngine" is not among the lines of the stacksInUse then
      start using stack "animationEngine"
   end if
   
   aeSetFrameRate 60 // Set the Animation Engine frame rate   
   restoreGame
   
end openStack

## Restores game's state on open
on restoreGame
   
   // Prefs   
   If there is a file "prefs.txt" then
      
      put URL ("file:prefs.txt") into tPrefs // Get prefs from file
      split tPrefs by return and ":" // Split into array   
      //set the customProperties["cPrefs"] of this stack to tPrefs // Set the tPrefs custom property to value of array
      
      // Amend Settings card UI
      
   end if
   
   // State
   If there is a file "state.txt" then
      
      put URL ("file:state.txt") into tState // Get state-related custom properties from file
      split tState by return and ":" // Split into array
      
      // Cycle through array and apply each line as a stack custom property
      repeat for each line tKey in the keys of tState         
         set the tKey of the current stack to tState[tKey]
      end repeat
      
   end if
   
   // High scores
   if there is a file "highscores.txt" then    
        
      put URL ("file:highscores.txt") into tHighScores // Get text file   
      split tHighScores by return and ":" // Split into array   
      set the customProperties["cHighScores"] of this stack to tHighScores // Set the array to value of cHighScores custom property
   
   end if 
   
end restoreGame

## Controls process when app is closed
on closeStack
   
   saveState
   savePrefs
   saveHighScores
   
end closeStack

## Saves game's state when app is closed
on saveState
   
   put "cCurrentLevel:" & the cCurrentLevel of this stack & return after tStateArray // Current level
   put "cCurrentSet:" & the cCurrentSet of this stack & return after tStateArray // Current set
   put "cTotalPoints:" & the cTotalPoints of this stack & return after tStateArray // Total points
   put "cFarthestPoint:" & the cFarthestPoint of this stack after tStateArray // Progress
   
   put tStateArray into URL ("file:state.txt") // Save to file
   
end saveState

## Saves game's preferences when app is closed
on savePrefs
   
   put the customProperties["cPrefs"] of the current stack into tPrefs // Get preferences custom property as an array
   
   // Cycle through the array and format for saving to file
   repeat for each line tKey in the keys of tPrefs
      put tKey & ":" & tPrefs[tKey] & return after tArrayContents
   end repeat
   
   put tArrayContents into URL ("file:prefs.txt") // Save to file
   
end savePrefs

## Saves game's high scores when app is closed
on saveHighScores
   
   put the customProperties["cHighScores"] of the current stack into tHighScores // Get high scores custom property as an array
   
   // Cycle through the array and format for saving to file
   repeat for each line tKey in the keys of tHighScores
      put tKey & ":" & tHighScores[tKey] & return after tArrayContents
   end repeat
   
   put tArrayContents into URL ("file:highscores.txt") // Save to file
   
end saveHighScores

## Level launch controller
on launchLevel
      
   configureLevelCard
   
   go cd "level"
   
   positionLevelElements
   
   setupLevel
   startGame

end launchLevel

## Copies controls from relevant level template to the actual level card
on configureLevelCard
   
   put the cCurrentSet of this stack into tCurrentSet // Get current set   
   put "set" & tCurrentSet & "_level" & the cCurrentLevel of this stack into tCurrentLevel // Get level name
   put the customProperties[tCurrentLevel] of this stack into tLevelProperties // Get level's custom properties
   put tLevelProperties into sLevelProperties // Make level properties available to whole script
   put tLevelProperties["cLevelTemplate"] into tTemplateName
   deleteControlsFromCard "level" // Delete any existing controls from the "level" card
   
   repeat with tControl = 1 to the number of controls in cd tLevelProperties["cLevelTemplate"] // Go through all controls in template card
      put the long name of control tControl of card tTemplateName into tControlName // Get control name     
      if "group" is in tControlName and word 1 of tControlName is "group" or "group" is not in tControlName then // Don't want to clone children of groups twice 
         copy control tControl of card tTemplateName to card "level" // Copy them over to the level
      end if
   end repeat
   
   ## Populate src element buttons with images relevant to this level
   
   put tLevelProperties["cFootImageGrps"] into tFootImageGrps // Get image groups used for each foot
   split tFootImageGrps by return and ":" // Split into array
   
   repeat for each line tKey in the keys of tFootImageGrps
      put tFootImageGrps[tKey] & "@2x" into tFootImage // Concatenate foot image name
      put "foot" & tKey & "_src" into tButtonName // Concatenate button name      
      set the cAnim of btn tButtonName of cd "level" to the cAnim of grp tFootImageGrps[tKey] of the cd "elements" // Apply animation image list (from foot group custom properties) to the foot
      setControlIcon tButtonName, "level", tFootImage, "elements" // Set the icon
      
      put tFootImageGrps[tKey] & "_landing@2x" into tFootLandingImage // Concatenate foot landing image name
      put "landing" & tKey & "_src" into tButtonName // Concatenate button name
      setControlIcon tButtonName, "level", tFootLandingImage, "elements" // Set the icon
      
   end repeat
   
end configureLevelCard

## Position the relevant elements (to cater for different screen sizes)

on positionLevelElements
   
   set the loc of btn "grid" of the cd "level" to the loc of this card // Center game grid
   put the width of this card - the right of btn "grid" into tMargin
   
   // Position moves counter
   set the left of fld "moves" of the cd "level" to tMargin - 6 // -6 because text adds its own margins
   set the left of btn "moves_value" of the cd "level" to the right of fld "moves" of the cd "level"
   set the top of fld "moves" of the cd "level" to tMargin - 12
   set the top of btn "moves_value" of the cd "level" to tMargin - 12
   
   // Position "Previous Best" fields
   set the left of fld "previous_best" of the cd "level" to tMargin - 6
   set the left of btn "previous_best_value" of the cd "level" to the right of fld "previous_best" of the cd "level"   
   set the top of fld "previous_best" to the bottom of btn "moves_value" of the cd "level" - 6
   set the top of btn "previous_best_value" to the bottom of btn "moves_value" of the cd "level" - 6
   
   // Position "Exit" button   
   set the bottom of group "stop_btn" of the cd "level" to the height of this cd - tMargin
   set the right of group "stop_btn" of the cd "level" to the width of this cd - tMargin
   
   if the environment is "mobile" then
      
      set the loc of btn "bg" of the cd "level" to the loc of the cd "level"
      set the loc of btn "grid" of the cd "level" to the loc of the cd "level"
      
   end if
   
end positionLevelElements

## Level setup

on setupLevel
   
   put the width of btn "grid" into tGridWidth // Get width of grid
   put 500 into sJumpAnimateSpeed // Speed in ms jump
   put 340 into sPivotAnimateSpeed // Speed in ms pivot
   
   // Get width of each circular 'cell'
   if tGridWidth is 608 then // 8x8 grid
      put the width of btn "grid" / 8 into sCellWidth      
   else if tGridWidth is 600 then // 6x6 grid
      put the width of btn "grid" / 6 into sCellWidth
      put sJumpAnimateSpeed / 8 * 9 into sJumpAnimateSpeed // Slightly slower speed in ms jump
      put sPivotAnimateSpeed / 8 * 9 into sPivotAsPivotAnimateSpeednimateSpeed // Slightly slower speed in ms pivot
   end if
   
   put sCellWidth / 2 + the left of btn "grid" into tX // Work out starting point on X axis
   put sCellWidth / 2 + the top of btn "grid" into tY // And the Y
   
   put sLevelProperties["cElementPlacement"] into tElPlacement // Get placement grid
   
   lock screen
   
   repeat for each line l in tElPlacement -- Cycle through each line
      
      repeat for each item el in l -- Cycle through each cell
         
         ## Check button type
         if el is 4 then -- Block
            clone button "block_src"
            set the name of it to "block"
         else if el is 1 then -- Foot 1
            clone button "foot1_src"
            set the name of it to "foot1"
            set the class of it to "foot"
         else if el is 2 then -- Foot 2
            clone button "foot2_src"
            set the name of it to "foot2"
            set the class of it to "foot"
         else if el is 3 then -- Foot 3
            clone button "foot3_src"
            set the name of it to "foot3"
            set the class of it to "foot"
         else if el is 5 then -- Landing 1
            clone button "landing1_src"
            set the name of it to "landing1"
            set the class of it to "landing"
         else if el is 6 then -- Landing 2
            clone button "landing2_src"
            set the name of it to "landing2"
            set the class of it to "landing"
         else if el is 7 then -- Landing 3
            clone button "landing3_src"
            set the name of it to "landing3"
            set the class of it to "landing"
         else if el is 8 then -- Pivot
            clone button "pivot_src"
            set the name of it to "pivot"
            set the visible of it to false
         end if
         
         if el is not 0 then
            set the loc of the last button to tX,tY -- Place button on grid
         end if
         
         put tX + sCellWidth into tX -- Next cell
         
      end repeat 
      
      put sCellWidth / 2 + the left of button "grid" into tX -- Back to beginning of row
      put tY + sCellWidth into tY -- Next row
      
   end repeat   
   
   unlock screen
   
   // Bring sprite to top
   set the layer of btn "foot3" to top
   set the layer of btn "foot2" to top
   set the layer of btn "foot1" to top
   set the layer of btn "pivot" to top
   
   ## Store the starting positions of the feet
   
   put item 1 of the loc of btn "foot1" into sFoot1Loc["x"] // X
   put item 2 of the loc of btn "foot1" into sFoot1Loc["y"] // Y
   
   put item 1 of the loc of btn "foot2" into sFoot2Loc["x"]
   put item 2 of the loc of btn "foot2" into sFoot2Loc["y"]
   
   put item 1 of the loc of btn "foot3" into sFoot3Loc["x"]
   put item 2 of the loc of btn "foot3" into sFoot3Loc["y"]   
   
   ## Store pivot position
   
   put the loc of btn "pivot" into sPivotLoc
   
   ## Set various level values
   
   put false into sChangeInFootPos
   put 0 into sMovesCounter // Reset move counter
   put false into sCollision // Set collision flag to false
   //put empty into sFootLandingLocs // Empty target foot location array
   set the label of button "moves_value" to sMovesCounter // Amend moves counter
   put false into sCheckingForWin // Prevents further moves while code checks to see whether use has positioned feet at the target locations
   put false into sLevelWon
   put empty into sCurrentAnimation
   put empty into sTouchStartLoc
   put empty into gTouchStartLoc
   
   // Clear landing location arrays
   put empty into sFootLanding1Locs
   put empty into sFootLanding2Locs
   put empty into sFootLanding3Locs
   
   ## Calculate landing locs
   
   // Get the icon ID of each foot
   put the icon of btn "foot1" into tFoot1Icon
   put the icon of btn "foot2" into tFoot2Icon
   put the icon of btn "foot3" into tFoot3Icon
   
   // Get the locs of the three landing spots
   put the loc of btn "landing1" into tLanding1Loc
   put the loc of btn "landing2" into tLanding2Loc
   put the loc of btn "landing3" into tLanding3Loc
   
   if tFoot1Icon is tFoot2Icon and tFoot1Icon is tFoot3Icon then // If all feet use the same icon      
      
      // Create temp array
      put tLanding1Loc into tArray[1]
      put tLanding2Loc into tArray[2]
      put tLanding3Loc into tArray[3]
      
      // Put the array into the landing locs array
      put tArray into sFootLanding1Locs
      put tArray into sFootLanding2Locs
      put tArray into sFootLanding3Locs
      
   else if tFoot1Icon is tFoot2Icon and tFoot1Icon is not tFoot3Icon then // If feet 1 and 2 are the same
      
      put tLanding1Loc into tArray[1]
      put tLanding2Loc into tArray[2]
      
      put tArray into sFootLanding1Locs
      put tArray into sFootLanding2Locs
      
      put tLanding3Loc into sFootLanding3Locs[1]
      
   else if tFoot2Icon is tFoot3Icon and tFoot1Icon is not tFoot3Icon then // If feet 2 and 3 are the same
      
      put tLanding2Loc into tArray[1]
      put tLanding3Loc into tArray[2]
      
      put tArray into sFootLanding2Locs
      put tArray into sFootLanding3Locs
      
      put tLanding1Loc into sFootLanding1Locs[1]
      
   else if tFoot1Icon is tFoot3Icon and tFoot1Icon is not tFoot2Icon then // If feet 1 and 3 are the same
      
      put tLanding1Loc into tArray[1]
      put tLanding3Loc into tArray[2]
      
      put tArray into sFootLanding1Locs
      put tArray into sFootLanding3Locs
      
      put tLanding2Loc into sFootLanding2Locs[1]
      
   else // If all feet have different icons
      
      put tLanding1Loc into sFootLanding1Locs[1]
      put tLanding2Loc into sFootLanding2Locs[1]
      put tLanding3Loc into sFootLanding3Locs[1]
      
   end if
   
   put the cTotalMovesRemaining of the current stack into fld "moves_remaining" of cd "settings"
   set the label of button "time_value" to 0
   
end setupLevel

// Hide the sprite

on hideSprite
   
   set the vis of button "foot1" to false
   set the vis of button "foot2" to false
   set the vis of button "foot3" to false
   
end hideSprite

// Flash the sprite

on aeWrapper pAEFunc, pMilliSecs
   
   if pAEFunc is "fadeIn" then
      aeLockMoves
      aeFadeIn the long id of btn "foot1",pMilliSecs
      aeFadeIn the long id of btn "foot2",pMilliSecs
      aeFadeIn the long id of btn "foot3",pMilliSecs
      aeUnlockMoves
   end if
   
   if pAEFunc is "fadeOut" then
      aeLockMoves
      aeFadeOut the long id of btn "foot1",pMilliSecs
      aeFadeOut the long id of btn "foot2",pMilliSecs
      aeFadeOut the long id of btn "foot3",pMilliSecs
      aeUnlockMoves
   end if
   
end aeWrapper

on flashSprite
   
   put 200 into flashSpeed
   put the long ID of btn "pivot" into tPivot
   
   if not sLevelWon then send "aefadeIn tPivot, flashSpeed" to me in 750 millisecs // Fade in pivot
   
   // Flash feet   
   send "aeWrapper fadeIn, flashSpeed" to me in 450 millisecs
   send "aeWrapper fadeIn, flashSpeed" to me in 750 millisecs
   
end flashSprite

on test
   
   aeStopMoving the long ID of btn "bg" of the cd "level"
   cancelPendingMessages
   
end test

on clearLevel   
   
   // Delete level objects from card
   put the number of buttons of this card into tCount
   repeat with x = tCount down to 1
        if the class of button x of this card is "foot" or the class of button x of this card is "landing" or the class of button x of this card is "shadowFoot" or the short name of button x of this card is "block" or the short name of button x of this card is "pivot" then
             delete button x of this card
        end if
   end repeat
   
end clearLevel   
   
on animateBackground
   
   put "bg" into tBackground
   put "level" into tCard
   
   send "aeMoveTo the long id of btn tBackground of the card tCard, 0, item 2 of the loc of this card, 20000" to me in 1 millisecs // To right
   send "aeMoveTo the long id of btn tBackground of the card tCard, the width of this card, item 2 of the loc of this card, 20000" to me in 20100 millisecs // To left
   
   if sGameRunning then
      
      send "animateBackground" to me in 40200 millisecs // Repeat animation
      
   end if
   
end animateBackground   
   
on startGame
   
   repositionPivot "launch"
   flashSprite
   put true into sGameRunning   
   put the loc of this card into tCardLoc
   set the loc of btn "bg" to the loc of this card // Background image to centre
   //animateBackground
   
end startGame

on stopGame
   
   aeStopMoving the long ID of btn "bg" of the cd "level" // Stop background moving
   put false into sGameRunning // Amend script-level flag
   set the pJumpTriggered of the cd "level" to false // Reset jump custom property
   cancelPendingMessages // Cancel any pending messages
   
end stopGame

on startTimer
   
   put the seconds into sTime
   goTimer
   
end startTimer

on goTimer
   
   // Stop time when game stops running
   if not sGameRunning then
      exit to top
   end if
   
   set the label of btn "time_value" to 0 + (the seconds - sTime)
   send "goTimer" to me in 1 millisec
   
end goTimer

on incrMoves
   
   if sGameRunning then
            
      set the label of button "moves_value" to sMovesCounter // Amend moves counter
      set the cTotalMovesRemaining of the current stack to the cTotalMovesRemaining of the current stack - 1 // Total moves--
      put the cTotalMovesRemaining of the current stack into fld "moves_remaining" of cd "settings" // Amend total moves counter
      
   end if
   
end incrMoves

on goJump pX, pY, pPivotX, pPivotY, pFootShortName, pDirection
   
   put false into tBoundaryHit
   
   // Get coords of previous foot loc
   put the loc of button pFootShortName into tPreMoveFootPos
   put item 1 of tPreMoveFootPos into tFootPrevX
   put item 2 of tPreMoveFootPos into tFootPrevY
   
   // Get coords of grid boundary
   put the top of button "grid" into tGridTop
   put the bottom of button "grid" into tGridBottom
   put the left of button "grid" into tGridLeft
   put the right of button "grid" into tGridRight
   
   set the layer of btn pFootShortName to top // Bring foot to front   
   
   if pY < tGridTop or pY > tGridBottom or pX < tGridLeft or pX > tGridRight then // If game area boundary will be hit
      
      put true into tBoundaryHit
      
   end if  
   
   put "inOut" into tJumpEffect // Default jump easing effect
   put sJumpAnimateSpeed into tJumpAnimateSpeed
   
   // Detect collision with block
   set the loc of btn "shadowFoot1" to pX,pY // Set position of a shadow foot to check for imminent collisions  
   put detectCollision() into tJumpCollide
   
   if tBoundaryHit then 
      put 10 into tJumpAnimTimer
   else
      put 14 into tJumpAnimTimer
   end if
   
   //send "hidePivot 100" to me in 1 millisecs // Fade out pivot   
   animateFoot pFootShortName, tJumpAnimTimer // Start foot 'jump' animation
   
   if tJumpCollide and not tBoundaryHit then // If the foot will jump onto a block
      
      put "jumpFail" into sCurrentAnimation
      
      aeLockMoves
      aeMoveTo the long id of btn pFootShortName,pX,pY,sJumpAnimateSpeed,tJumpEffect
      aeUnlockMoves
      
      send "animateFoot pFootShortName, 20" to me in sJumpAnimateSpeed + 400 millisecs // Start foot 'jump' animation
      send "jumpBack pFootShortName, tFootPrevX, tFootPrevY, inOut" to btn pFootShortName in sJumpAnimateSpeed + 400 millisecs // Call jumpBack() after a short interval
      //send "showPivot 150" to me in sJumpAnimateSpeed + 700 millisecs // Fade pivot back in
      
   else if tBoundaryHit then // If boundary will be hit
      
      if pDirection is "N" then
         put item 1 of the loc of btn pFootShortName into pX // X pos will be the same
         put the top of btn "grid" + (sCellWidth / 2) into pY // Jump to top of grid
      else if pDirection is "E" then
         put the right of btn "grid" - (sCellWidth / 2) into pX
         put item 2 of the loc of btn pFootShortName into pY
      else if pDirection is "S" then
         put item 1 of the loc of btn pFootShortName into pX
         put the bottom of btn "grid" - (sCellWidth / 2) into pY
      else if pDirection is "W" then
         put the left of btn "grid" + (sCellWidth / 2) into pX
         put item 2 of the loc of btn pFootShortName into pY
      else // For other jump directions, we'll move to the triangle centroid
         
         // Position shadow feet in what would be the post-jump positions (pFootShortName is, of course, out of bounds)
         if pFootShortName is "foot1" then
            set the loc of btn "shadowFoot1" to pX,pY
            set the loc of btn "shadowFoot2" to the loc of btn "foot2"
            set the loc of btn "shadowFoot3" to the loc of btn "foot3"
         else if pFootShortName is "foot2" then
            set the loc of btn "shadowFoot2" to pX,pY
            set the loc of btn "shadowFoot1" to the loc of btn "foot1"
            set the loc of btn "shadowFoot3" to the loc of btn "foot3"
         else if pFootShortName is "foot3" then
            set the loc of btn "shadowFoot3" to pX,pY
            set the loc of btn "shadowFoot1" to the loc of btn "foot1"
            set the loc of btn "shadowFoot2" to the loc of btn "foot2"
         end if
         
         // Get coords of the shadow feet
         put item 1 of the loc of btn "shadowFoot1" into x1
         put item 1 of the loc of btn "shadowFoot2" into x2
         put item 1 of the loc of btn "shadowFoot3" into x3
         
         put item 2 of the loc of btn "shadowFoot1" into y1
         put item 2 of the loc of btn "shadowFoot2" into y2
         put item 2 of the loc of btn "shadowFoot3" into y3
         
         put getTriangleCentroid(x1, x2, x3, y1, y2, y3) into tCentroid // Get centroid
         
         // Modify coord parameters to centroid coords
         put round(item 1 of tCentroid) into pX
         put round(item 2 of tCentroid) into pY
         
      end if
      
      put round(sJumpAnimateSpeed / 1.5) into tJumpAnimateSpeed
      
      // Set timer for jump back to where the foot was
      send "jumpBack pFootShortName, tFootPrevX, tFootPrevY, bounce" to me in (tJumpAnimateSpeed + 100) milliseconds // Jump back after short wait
      //send "showPivot 150" to me in (sJumpAnimateSpeed + 250) millisecs // Show the pivot
      
   end if
   
   if not tJumpCollide then
      
      // Do the jump
      aeLockMoves
      aeMoveTo the long id of btn pFootShortName,pX,pY,tJumpAnimateSpeed,tJumpEffect
      aeUnlockMoves
      
   end if
   
   if not tBoundaryHit and not tJumpCollide then // If a boundary hasn't been hit, or the foot hasn't jumped onto a block
      
      put sMovesCounter + 1 into sMovesCounter // sMovesCounter++
      send "incrMoves" to this card in sJumpAnimateSpeed milliseconds // Increment moves counter
      
      if pFootShortName is "foot1" then // Update script-level loc for relevant foot
         put pX into sFoot1Loc["x"]
         put pY into sFoot1Loc["y"]
      else if pFootShortName is "foot2" then
         put pX into sFoot2Loc["x"]
         put pY into sFoot2Loc["y"]
      else if pFootShortName is "foot3" then
         put pX into sFoot3Loc["x"]
         put pY into sFoot3Loc["y"]
      end if
   end if
   
end goJump

## Fades out pivot

on hidePivot pSpeed
   
   if sGameRunning then
      
      put the long ID of btn "pivot" into tPivot      
      aeFadeOut tPivot, pSpeed
      
   end if
   
end hidePivot

## Fades in pivot and puts to top layer

on showPivot pSpeed
   
   if sGameRunning and not sLevelWon then
      
      put the long ID of btn "pivot" into tPivot   
      set the layer of tPivot to top
      aePivotFadeIn tPivot, pSpeed
      
   end if   
   
end showPivot

## Animates lift and drop of foot

on goAnimate pFootShortName, imageID
   set the icon of btn pFootShortName to imageID
end goAnimate

## Control animation for lift and drop of foot

on animateFoot pFootShortName, pFrameRateFactor
   
   put the imgGrp of btn pFootShortName into tImgGrpID // Get the ID of the image group which corresponds with this foot
   put the cAnim of btn pFootShortName into tAnimImages // Get the anim custom property of the group (in the "elements" card). This lists the images which will be used in the animation
   
   put round(sJumpAnimateSpeed / pFrameRateFactor) into tAnimInc // Calculate a 'frame rate'
   put 1 into tMultiplier // So animation frames change at right moment
   
   // Do the animation
   repeat for each line tImgID in tAnimImages
      send "goAnimate pFootShortName, tImgID" to btn pFootShortName in tAnimInc * tMultiplier milliseconds
      put tMultiplier + 1 into tMultiplier
   end repeat
   
end animateFoot

on repositionPivot pEvent
   
   if sGameRunning or pEvent is "launch" or sLevelWon then // If during gameplay, or as we're just starting the game, or we've just won a level
      
      // Get angles of foot one to other two feet
      put the loc of btn "foot1" into tFoot1
      put the loc of btn "foot2" into tFoot2
      put the loc of btn "foot3" into tFoot3
      
      put getAngleBetweenPoints(tFoot1, tFoot2) into tAngle12
      put getAngleBetweenPoints(tFoot1, tFoot3) into tAngle13
      
      put round(sCellWidth / 6) into tPivotShift // The pivot will be moved by slightly more than the cell width
      
      ## For clockwise arrangement 1, 2, 3
      
      if tAngle12 is 63 and tAngle13 is 117 then // Position 1
         put item 1 of tFoot1 into tPivotX
         put item 2 of tFoot1 + sCellWidth + tPivotShift into tPivotY
         
      else if tAngle12 is 90 and tAngle13 is 153 then // Position 2
         put item 2 of tFoot3 into tPivotY
         put item 1 of tFoot3 + sCellWidth + tPivotShift into tPivotX
         
      else if tAngle12 is 117 and tAngle13 is 180 then // Position 3
         put item 1 of tFoot2 into tPivotX
         put item 2 of tFoot2 - sCellWidth - tPivotShift into tPivotY
         
      else if tAngle12 is 153 and tAngle13 is -153 then // Position 4
         put item 2 of tFoot1 into tPivotY
         put item 1 of tFoot1 - sCellWidth - tPivotShift into tPivotX
         
      else if tAngle12 is 180 and tAngle13 is -117 then // Position 5
         put item 1 of tFoot3 into tPivotX
         put item 2 of tFoot3 + sCellWidth + tPivotShift into tPivotY
         
      else if tAngle12 is -153 and tAngle13 is -90 then // Position 6
         put item 2 of tFoot2 into tPivotY
         put item 1 of tFoot2 + sCellWidth + tPivotShift into tPivotX
         
      else if tAngle12 is -117 and tAngle13 is -63 then // Position 7
         put item 1 of tFoot1 into tPivotX
         put item 2 of tFoot1 - sCellWidth - tPivotShift into tPivotY
         
      else if tAngle12 is -90 and tAngle13 is -27 then // Position 8
         put item 2 of tFoot3 into tPivotY
         put item 1 of tFoot3 - sCellWidth - tPivotShift into tPivotX
         
      else if tAngle12 is -63 and tAngle13 is 0 then // Position 9
         put item 1 of tFoot2 into tPivotX
         put item 2 of tFoot2 + sCellWidth + tPivotShift into tPivotY
         
      else if tAngle12 is -27 and tAngle13 is 27 then // Position 10
         put item 2 of tFoot1 into tPivotY
         put item 1 of tFoot1 + sCellWidth + tPivotShift into tPivotX
         
      else if tAngle12 is 0 and tAngle13 is 63 then // Position 11
         put item 1 of tFoot3 into tPivotX
         put item 2 of tFoot3 - sCellWidth - tPivotShift into tPivotY
         
      else if tAngle12 is 27 and tAngle13 is 90 then // Position 12
         put item 2 of tFoot2 into tPivotY
         put item 1 of tFoot2 - sCellWidth - tPivotShift into tPivotX
         
      else if tAngle13 is 63 and tAngle12 is 117 then // Position 1 (clockwise 1, 3, 2)         
         put item 1 of tFoot1 into tPivotX
         put item 2 of tFoot1 + sCellWidth + tPivotShift into tPivotY
         
      else if tAngle13 is 90 and tAngle12 is 153 then // Position 2
         put item 2 of tFoot2 into tPivotY
         put item 1 of tFoot2 + sCellWidth + tPivotShift into tPivotX
         
      else if tAngle13 is 117 and tAngle12 is 180 then // Position 3
         put item 1 of tFoot3 into tPivotX
         put item 2 of tFoot3 - sCellWidth - tPivotShift into tPivotY
         
      else if tAngle13 is 153 and tAngle12 is -153 then // Position 4
         put item 2 of tFoot1 into tPivotY
         put item 1 of tFoot1 - sCellWidth - tPivotShift into tPivotX
         
      else if tAngle13 is 180 and tAngle12 is -117 then // Position 5
         put item 1 of tFoot2 into tPivotX
         put item 2 of tFoot2 + sCellWidth + tPivotShift into tPivotY
         
      else if tAngle13 is -153 and tAngle12 is -90 then // Position 6
         put item 2 of tFoot3 into tPivotY
         put item 1 of tFoot3 + sCellWidth + tPivotShift into tPivotX
         
      else if tAngle13 is -117 and tAngle12 is -63 then // Position 7
         put item 1 of tFoot1 into tPivotX
         put item 2 of tFoot1 - sCellWidth - tPivotShift into tPivotY
         
      else if tAngle13 is -90 and tAngle12 is -27 then // Position 8
         put item 2 of tFoot2 into tPivotY
         put item 1 of tFoot2 - sCellWidth - tPivotShift into tPivotX
         
      else if tAngle13 is -63 and tAngle12 is 0 then // Position 9
         put item 1 of tFoot3 into tPivotX
         put item 2 of tFoot3 + sCellWidth + tPivotShift into tPivotY
         
      else if tAngle13 is -27 and tAngle12 is 27 then // Position 10
         put item 2 of tFoot1 into tPivotY
         put item 1 of tFoot1 + sCellWidth + tPivotShift into tPivotX
         
      else if tAngle13 is 0 and tAngle12 is 63 then // Position 11
         put item 1 of tFoot2 into tPivotX
         put item 2 of tFoot2 - sCellWidth - tPivotShift into tPivotY
         
      else if tAngle13 is 27 and tAngle12 is 90 then // Position 12
         put item 2 of tFoot3 into tPivotY
         put item 1 of tFoot3 - sCellWidth - tPivotShift into tPivotX
      else
         // Just a bit of defensive programming for the pivot to stay still if none of the above conditions is met (so tPivotX and tPivotY have a value) 
         put item 1 of the loc of btn "pivot" into tPivotX
         put item 2 of the loc of btn "pivot" into tPivotY
      end if
      
      put tPivotX,tPivotY into sPivotLoc
      
      if the loc of btn "pivot" is not sPivotLoc and sCurrentAnimation is "pivot" then // If the pivot needs to change location after a pivot move
         put the long ID of btn "pivot" into tPivot
         send "aeMoveTo tPivot, item 1 of sPivotLoc, item 2 of sPivotLoc, 200" to me in 1 millisecs
      else if the loc of btn "pivot" is not sPivotLoc and sCurrentAnimation is "jump" then // If the pivot needs to change location after a jump
         set the loc of btn "pivot" to sPivotLoc // Set new loc right away
      else if not sGameRunning then // On card load, before game is running
         set the loc of btn "pivot" to sPivotLoc  
      end if
      
   end if
   
end repositionPivot
   
on jump pFootLoc, pFootShortName
   
   if not sCheckingForWin and not isAnimating() then
      
      resetShowFeet
      
      put "jump" into sCurrentAnimation
      
      put 1 into tFootCount
      // Cycle through all feet
      
      repeat with tControl = 1 to the number of controls in current card // Go through all card controls
         
         if the class of control tControl is "foot" then // If the control is a foot
            
            put "foot" & tFootCount into tFoot
            put the loc of button tFoot into tFootLoc // Get the location of this foot
            
            if tFootLoc is not pFootLoc then // If this isn't the foot we've swiped
               put tFootLoc into tOtherFeetLocs[tFootCount] // Store the coordinates of this foot
            end if
            
            put tFootCount + 1 into tFootCount
         end if
         
      end repeat
      
      put 1 into tCount
      repeat for each element tElement in tOtherFeetLocs // For each of the other two foot locations
         put getAngleBetweenPoints(pFootLoc, tElement) into tAngles[tCount] // Get the angle between the swiped foot and the location of the other foot
         put tCount + 1 into tCount
      end repeat
      
      put item 1 of the loc of button pFootShortName into tX // Get current x pos of the swiped foot
      put item 2 of the loc of button pFootShortName into tY // Get current y pos of the swiped foot
      put item 1 of the loc of button "pivot" into tPivotX // Get current x pos of the pivot
      put item 2 of the loc of button "pivot" into tPivotY // Get current y pos of the pivot      
      
      // Read angles and work out in which direct the foot needs to jump
      if tAngles[1] is -117 and tAngles[2] is -63 or tAngles[2] is -117 and tAngles[1] is -63 then // N    
         put tY - (sCellWidth * 4) into tY // Amend the y pos of swiped foot
         put "N" into tDirection
      else if tAngles[1] is -27 and tAngles[2] is 27 or tAngles[2] is -27 and tAngles[1] is 27 then // E
         put tX + (sCellWidth * 4) into tX
         put "E" into tDirection
      else if tAngles[1] is 117 and tAngles[2] is 63 or tAngles[2] is 117 and tAngles[1] is 63 then // S      
         put tY + (sCellWidth * 4) into tY 
         put "S" into tDirection
      else if tAngles[1] is -153 and tAngles[2] is 153 or tAngles[2] is -153 and tAngles[1] is 153 then // W
         put tX - (sCellWidth * 4) into tX 
         put "W" into tDirection
      else if tAngles[1] is -117 and tAngles[2] is 180 or tAngles[2] is -117 and tAngles[1] is 180 then // NW
         put tY - (sCellWidth * 2) into tY
         put tX - (sCellWidth * 3) into tX
         put "NW" into tDirection
      else if tAngles[1] is -153 and tAngles[2] is -90 or tAngles[2] is -153 and tAngles[1] is -90 then // NNW    
         put tY - (sCellWidth * 3) into tY
         put tX - (sCellWidth * 2) into tX
         put "NNW" into tDirection
      else if tAngles[1] is 0 and tAngles[2] is -63 or tAngles[2] is 0 and tAngles[1] is -63 then // NE
         put tY - (sCellWidth * 2) into tY
         put tX + (sCellWidth * 3) into tX
         put "NE" into tDirection
      else if tAngles[1] is -90 and tAngles[2] is -27 or tAngles[2] is -90 and tAngles[1] is -27 then // NNE    
         put tY - (sCellWidth * 3) into tY
         put tX + (sCellWidth * 2) into tX
         put "NNE" into tDirection
      else if tAngles[1] is 0 and tAngles[2] is 63 or tAngles[2] is 0 and tAngles[1] is 63 then // SE
         put tY + (sCellWidth * 2) into tY
         put tX + (sCellWidth * 3) into tX
         put "SE" into tDirection
      else if tAngles[1] is 90 and tAngles[2] is 27 or tAngles[2] is 90 and tAngles[1] is 27 then // SSE    
         put tY + (sCellWidth * 3) into tY
         put tX + (sCellWidth * 2) into tX
         put "SSE" into tDirection
      else if tAngles[1] is 117 and tAngles[2] is 180 or tAngles[2] is 117 and tAngles[1] is 180 then // SW    
         put tY + (sCellWidth * 2) into tY
         put tX - (sCellWidth * 3) into tX
         put "SW" into tDirection
      else if tAngles[1] is 153 and tAngles[2] is 90 or tAngles[2] is 153 and tAngles[1] is 90 then // SSW    
         put tY + (sCellWidth * 3) into tY
         put tX - (sCellWidth * 2) into tX
         put "SSW" into tDirection
      end if
      
      goJump tX, tY, tPivotX, tPivotY, pFootShortName, tDirection // Do the jump, passing in the new x and y coords of the swiped foot and pivot, and the foot name
   end if
end jump

on resetShowFeet
   set the loc of btn "shadowFoot1" to 0,0
   set the loc of btn "shadowFoot2" to 0,0
   set the loc of btn "shadowFoot3" to 0,0
end resetShowFeet

on pivot
   if not sCheckingForWin and not isAnimating() then // If no element is currently being animated, and we're not checking for a win
      
      resetShowFeet
      
      put "pivot" into sCurrentAnimation
      
      put the loc of btn "foot1" into tLastStationaryPos1
      put the loc of btn "foot2" into tLastStationaryPos2
      put the loc of btn "foot3" into tLastStationaryPos3
      
      split tLastStationaryPos1 by ","
      split tLastStationaryPos2 by ","
      split tLastStationaryPos3 by ","     
      
      put getAngleBetweenPoints(the loc of button "foot1", the loc of button "foot2") into tAngle12
      put getAngleBetweenPoints(the loc of button "foot1", the loc of button "foot3") into tAngle13
      
      ## For clockwise arrangement 1, 2, 3
      
      if tAngle12 is 63 and tAngle13 is 117 then // Position 1
         put sFoot1Loc["x"] + sCellWidth into sFoot1Loc["x"] // Move foot 1 to the right
         put sFoot3Loc["y"] - sCellWidth into sFoot3Loc["y"] // Move foot 3 up
         
      else if tAngle12 is 90 and tAngle13 is 153 then // Position 2
         put sFoot2Loc["x"] - sCellWidth into sFoot2Loc["x"] // Foot 2 left
         put sFoot3Loc["y"] - sCellWidth into sFoot3Loc["y"] // Foot 3 up 
         
      else if tAngle12 is 117 and tAngle13 is 180 then // Position 3
         put sFoot2Loc["x"] - sCellWidth into sFoot2Loc["x"] // Foot 2 left
         put sFoot1Loc["y"] + sCellWidth into sFoot1Loc["y"] // Foot 1 down 
         
      else if tAngle12 is 153 and tAngle13 is -153 then // Position 4
         put sFoot3Loc["x"] + sCellWidth into sFoot3Loc["x"] // Foot 3 right
         put sFoot1Loc["y"] + sCellWidth into sFoot1Loc["y"] // Foot 1 down
         
      else if tAngle12 is 180 and tAngle13 is -117 then // Position 5
         put sFoot3Loc["x"] + sCellWidth into sFoot3Loc["x"] // Foot 3 right
         put sFoot2Loc["y"] - sCellWidth into sFoot2Loc["y"] // Foot 2 up
         
      else if tAngle12 is -153 and tAngle13 is -90 then // Position 6
         put sFoot1Loc["x"] - sCellWidth into sFoot1Loc["x"] // Foot 1 left
         put sFoot2Loc["y"] - sCellWidth into sFoot2Loc["y"] // Foot 2 up
         
      else if tAngle12 is -117 and tAngle13 is -63 then // Position 7
         put sFoot1Loc["x"] - sCellWidth into sFoot1Loc["x"] // Foot 1 left
         put sFoot3Loc["y"] + sCellWidth into sFoot3Loc["y"] // Foot 3 down
         
      else if tAngle12 is -90 and tAngle13 is -27 then // Position 8
         put sFoot2Loc["x"] + sCellWidth into sFoot2Loc["x"] // Foot 2 right
         put sFoot3Loc["y"] + sCellWidth into sFoot3Loc["y"] // Foot 3 down
         
      else if tAngle12 is -63 and tAngle13 is 0 then // Position 9
         put sFoot2Loc["x"] + sCellWidth into sFoot2Loc["x"] // Foot 2 right
         put sFoot1Loc["y"] - sCellWidth into sFoot1Loc["y"] // Foot 1 up
         
      else if tAngle12 is -27 and tAngle13 is 27 then // Position 10
         put sFoot3Loc["x"] - sCellWidth into sFoot3Loc["x"] // Foot 3 left
         put sFoot1Loc["y"] - sCellWidth into sFoot1Loc["y"] // Foot 1 up
         
      else if tAngle12 is 0 and tAngle13 is 63 then // Position 11
         put sFoot3Loc["x"] - sCellWidth into sFoot3Loc["x"] // Foot 3 left
         put sFoot2Loc["y"] + sCellWidth into sFoot2Loc["y"] // Foot 2 down
         
      else if tAngle12 is 27 and tAngle13 is 90 then // Position 12
         put sFoot1Loc["x"] + sCellWidth into sFoot1Loc["x"] // Foot 1 right
         put sFoot2Loc["y"] + sCellWidth into sFoot2Loc["y"] // Foot 2 down        
         
      else if tAngle13 is 63 and tAngle12 is 117 then // Position 1 (clockwise 1, 3, 2)
         put sFoot1Loc["x"] + sCellWidth into sFoot1Loc["x"] // Move foot 1 to the right
         put sFoot2Loc["y"] - sCellWidth into sFoot2Loc["y"] // Move foot 2 up     
         
      else if tAngle13 is 90 and tAngle12 is 153 then // Position 2
         put sFoot3Loc["x"] - sCellWidth into sFoot3Loc["x"] // Foot 3 left
         put sFoot2Loc["y"] - sCellWidth into sFoot2Loc["y"] // Foot 2 up
         
      else if tAngle13 is 117 and tAngle12 is 180 then // Position 3
         put sFoot3Loc["x"] - sCellWidth into sFoot3Loc["x"] // Foot 3 left
         put sFoot1Loc["y"] + sCellWidth into sFoot1Loc["y"] // Foot 1 down 
         
      else if tAngle13 is 153 and tAngle12 is -153 then // Position 4
         put sFoot2Loc["x"] + sCellWidth into sFoot2Loc["x"] // Foot 2 right
         put sFoot1Loc["y"] + sCellWidth into sFoot1Loc["y"] // Foot 1 down
         
      else if tAngle13 is 180 and tAngle12 is -117 then // Position 5
         put sFoot2Loc["x"] + sCellWidth into sFoot2Loc["x"] // Foot 2 right
         put sFoot3Loc["y"] - sCellWidth into sFoot3Loc["y"] // Foot 3 up
         
      else if tAngle13 is -153 and tAngle12 is -90 then // Position 6
         put sFoot1Loc["x"] - sCellWidth into sFoot1Loc["x"] // Foot 1 left
         put sFoot3Loc["y"] - sCellWidth into sFoot3Loc["y"] // Foot 3 up
         
      else if tAngle13 is -117 and tAngle12 is -63 then // Position 7
         put sFoot1Loc["x"] - sCellWidth into sFoot1Loc["x"] // Foot 1 left
         put sFoot2Loc["y"] + sCellWidth into sFoot2Loc["y"] // Foot 2 down
         
      else if tAngle13 is -90 and tAngle12 is -27 then // Position 8
         put sFoot3Loc["x"] + sCellWidth into sFoot3Loc["x"] // Foot 3 right
         put sFoot2Loc["y"] + sCellWidth into sFoot2Loc["y"] // Foot 2 down
         
      else if tAngle13 is -63 and tAngle12 is 0 then // Position 9
         put sFoot3Loc["x"] + sCellWidth into sFoot3Loc["x"] // Foot 3 right
         put sFoot1Loc["y"] - sCellWidth into sFoot1Loc["y"] // Foot 1 up
         
      else if tAngle13 is -27 and tAngle12 is 27 then // Position 10
         put sFoot2Loc["x"] - sCellWidth into sFoot2Loc["x"] // Foot 2 left
         put sFoot1Loc["y"] - sCellWidth into sFoot1Loc["y"] // Foot 1 up
         
      else if tAngle13 is 0 and tAngle12 is 63 then // Position 11
         put sFoot2Loc["x"] - sCellWidth into sFoot2Loc["x"] // Foot 2 left
         put sFoot3Loc["y"] + sCellWidth into sFoot3Loc["y"] // Foot 3 down
         
      else if tAngle13 is 27 and tAngle12 is 90 then // Position 12
         put sFoot1Loc["x"] + sCellWidth into sFoot1Loc["x"] // Foot 1 right
         put sFoot3Loc["y"] + sCellWidth into sFoot3Loc["y"] // Foot 3 down
         
      end if
      
      // Move feet
      put sFoot1Loc["x"] into tFoot1x
      put sFoot1Loc["y"] into tFoot1y
      set the loc of btn "shadowFoot1" to tFoot1x,tFoot1y // Set shadow foot to check for imminent collisions
      
      put sFoot2Loc["x"] into tFoot2x
      put sFoot2Loc["y"] into tFoot2y
      set the loc of btn "shadowFoot2" to tFoot2x,tFoot2y
      
      put sFoot3Loc["x"] into tFoot3x
      put sFoot3Loc["y"] into tFoot3y
      set the loc of btn "shadowFoot3" to tFoot3x,tFoot3y     
      
      if detectCollision() then // If collision
         
         // Put back values of feet positions - we won't be pivoting
         put item 1 of the loc of btn "foot1" into sFoot1Loc["x"]
         put item 2 of the loc of btn "foot1" into sFoot1Loc["y"]
         put item 1 of the loc of btn "foot2" into sFoot2Loc["x"]
         put item 2 of the loc of btn "foot2" into sFoot2Loc["y"]
         put item 1 of the loc of btn "foot3" into sFoot3Loc["x"]
         put item 2 of the loc of btn "foot3" into sFoot3Loc["y"]
         
         // Nudge feet
         nudge "foot1", tFoot1x, tFoot1y, sFoot1Loc["x"], sFoot1Loc["y"]
         nudge "foot2", tFoot2x, tFoot2y, sFoot2Loc["x"], sFoot2Loc["y"]
         nudge "foot3", tFoot3x, tFoot3y, sFoot3Loc["x"], sFoot3Loc["y"]
         
      else if the visible of btn "pivot" then // If no collision and pivot is visible, we can go ahead and pivot
         
         put sMovesCounter + 1 into sMovesCounter // sMovesCounter++
         
         put 0 into sFootPivotCount // Register than no feet have yet moved
         put the long ID of btn "pivot" into tPivot

         aeLockMoves
         aeMoveTo the long id of btn "foot1",tFoot1x,tFoot1y,sPivotAnimateSpeed,"overshoot"
         aeMoveTo the long id of btn "foot2",tFoot2x,tFoot2y,sPivotAnimateSpeed,"overshoot"
         aeMoveTo the long id of btn "foot3",tFoot3x,tFoot3y,sPivotAnimateSpeed,"overshoot"
         aeUnlockMoves
         
         send "incrMoves" to this card in sPivotAnimateSpeed milliseconds // Increment moves counter
         
      end if
      
   end if
   
end pivot

## Called by AE on completion of animation

on aeMoveDone
   
   if sCurrentAnimation is "pivot" and sFootPivotCount < 2 then // If we're pivoting but all three feet have not yet be repositioned
      
      put sFootPivotCount + 1 into sFootPivotCount // Increment foot count
      
   else if sCurrentAnimation is "pivot" and sFootPivotCount is 2 then // If the pivot is complete
      
      checkWin
      repositionPivot
      
   else if sCurrentAnimation is "jump" then // If we've just completed a jump
      
      checkWin
      repositionPivot
      
   end if
   
end aeMoveDone

function detectCollision 
   put false into tCollide
   repeat with tControl = 1 to the number of controls of current card // Cycle through card's controls
      if the short name of control tControl is "block" then // If this one's a block
         put the loc of control tControl into tBlockLoc // Get its location
         if tBlockLoc is the loc of btn "shadowFoot1" or tBlockLoc is the loc of btn "shadowFoot2" or tBlockLoc is the loc of btn "shadowFoot3" then // If the loc matches one of the shadow feet
            put true into tCollide // There has been a collision
            exit repeat
         end if
      end if
   end repeat
   
   return tCollide
end detectCollision

// Nudges feet on disallowed pivot attempt
on nudge pFoot, pFootX, pFootY, pFootCurrPosX, pFootCurrPosY // Foot, attempted X, attempted Y, pre-nudge X, pre-nudge Y
   
   put round(sCellWidth / 10) into nudgeAmount
   
   if item 1 of the loc of btn pFoot < pFootX then
      move btn pFoot to pFootCurrPosX + nudgeAmount, pFootCurrPosY in 50 milliseconds without waiting // Nudge right
   else if item 1 of the loc of btn pFoot > pFootX then
      move btn pFoot to pFootCurrPosX - nudgeAmount, pFootCurrPosY in 50 milliseconds without waiting // Nudge left
   else if item 2 of the loc of btn pFoot < pFootY then
      move btn pFoot to pFootCurrPosX, pFootCurrPosY + nudgeAmount in 50 milliseconds without waiting // Nudge down
   else if item 2 of the loc of btn pFoot > pFootY then
      move btn pFoot to pFootCurrPosX, pFootCurrPosY - nudgeAmount in 50 milliseconds without waiting // Nudge up
   end if
   
   send "nudgeBack pFoot, pFootCurrPosX, pFootCurrPosY" to btn pFoot in 275 milliseconds // Call nudgeBack() after a short interval
end nudge

// Nudges feet back to original position after disallowed pivot attempt
on nudgeBack pTarget,pX,pY,pTime
   move btn pTarget to pX,pY in 50 milliseconds without waiting
end nudgeBack

on jumpBack pTarget,pX,pY,pEffect
   aeMoveTo the long id of btn pTarget,pX,pY,round(sJumpAnimateSpeed / 1.5),pEffect
end jumpBack

## Check whether feet have landed correctly on respective landing locations

on checkWin
   
   if sGameRunning and not sCheckingForWin and not isAnimating() then
      
      put true into sCheckingForWin // Flag that we're checking for a win
      
      // Reset check for feet landing correctly
      put false into tFoot1LandSuccess
      put false into tFoot2LandSuccess
      put false into tFoot3LandSuccess
      
      // Foot 1       
      repeat for each element tLoc in sFootLanding1Locs // Get the locs at which foot is able to land for level to be won
         if item 1 of the loc of button "foot1" is item 1 of tLoc and item 2 of the loc of button "foot1" is item 2 of tLoc then // If the X and Y coords of the foot match one of the array items
            put true into tFoot1LandSuccess
         end if
      end repeat
      
      // Foot 2       
      repeat for each element tLoc in sFootLanding2Locs 
         if item 1 of the loc of button "foot2" is item 1 of tLoc and item 2 of the loc of button "foot2" is item 2 of tLoc then
            put true into tFoot2LandSuccess
         end if
      end repeat
      
      // Foot 3   
      repeat for each element tLoc in sFootLanding3Locs 
         if item 1 of the loc of button "foot3" is item 1 of tLoc and item 2 of the loc of button "foot3" is item 2 of tLoc then
            put true into tFoot3LandSuccess
         end if
      end repeat
      
      if tFoot1LandSuccess and tFoot2LandSuccess and tFoot3LandSuccess then // If all feet are in the right locations         
         levelWin // Run the level win routine         
      else         
         //if sCurrentAnimation is "jump" then showPivot 150 // Show the pivot if we've just successfully jumped       
         put false into sCheckingForWin // Flag that we're no longer checking for a win         
      end if
      
   end if
   
end checkWin

on levelWin
   
   put true into sLevelWon
   stopGame
   flashSprite
   
   aeFadeOut the long id of btn "stop", 250 // Fade out stop button
      
   if sCurrentAnimation is "pivot" then
      
      put "pivot" into tPivot   
      send "aeFadeOut the long id of btn tPivot, 100" to me in 250 millisecs // Fade out pivot if the winning move was a pivot, with a short delay to wait for pivot (just because it looks nicer)
   
   end if
   
   put "You've won the level!" into tWinMsg
   
   ## Check for high score
   
   put false into tNewHighScore
   
   put the cCurrentSet of this stack into tCurrentSet // Get current set
   put "set" & tCurrentSet & "_level" & the cCurrentLevel of this stack into tLevelName // Get level name
   put the cHighScores[tLevelName] of this stack into tCurrentHighScore // Get previous high score (will be empty on first attempt)
   
   set the cCurrentHighScore of cd "level_win" to tCurrentHighScore // Set current high score property of win card (could be empty)
   set the cNewHighScore of cd "level_win" to empty // Empty new high score property of win card
   set the cBonusPoints of cd "level_win" to empty // Empty bonus points custom property
   
   if tCurrentHighScore is empty or sMovesCounter < tCurrentHighScore then // If we've completed the level in fewer moves than our previous attempts, or this is the first time the level has been won
      
      put true into tNewHighScore // Flag that this is a new high score
      
   end if
   
   if tNewHighScore then // If it's a new high score
      
      put 5 into cBonusPoints // Give 5 bonus points
      
      // Record the current and new high scores for the win card
      set the cCurrentHighScore of cd "level_win" to the cHighScores[tLevelName] of this stack
      set the cNewHighScore of cd "level_win" to sMovesCounter
      
      set the cHighScores[tLevelName] of this stack to sMovesCounter // Set the high score for this level to current value of moves counter
      put "You have achieved a new personal best for this level of " & sMovesCounter & " moves!" into tNewHighScoreMsg
      
   else
      
      put empty into tNewHighScoreMsg
      
   end if
   
   set the cWinMsg of cd "level_win" to tWinMsg // Set the message custom property of the win card
   set the cNewHighScoreMsg of cd "level_win" to tNewHighScoreMsg // Set the new-high-score message of the win card
   send "showWinCard" to me in 1300 millisecs // Show card to tell user they've completed the level
   
   set the cStarRating of cd "level_win" to calculateStarRating() // Get and set star rating
   set the cLevelMoves of cd "level_win" to sMovesCounter // Store moves counter in win card custom property
   
   updateProgress tCurrentSet
   
end levelWin

## Update cFarthestPoint property to track the farthest point reached in the game
on updateProgress pCurrentSet
   
   put item 1 of the cFarthestPoint of this stack into tFarthestSet // Farthest set reach
   put item 2 of the cFarthestPoint of this stack into tFarthestLevel // Fartherst level in the farthest set
   put tFarthestSet into tFarthestArray[1] // Add to array
   put tFarthestLevel into tFarthestArray[2]
   put false into tHigherPointReached // Flag false by default
   
   if pCurrentSet is tFarthestSet and the cCurrentLevel of this stack > tFarthestLevel then // If we're progressing normally and we've just completed the next level in the set
      
      put the cCurrentLevel of this stack into tFarthestArray[2] // Update the farthest level of this set
      put true into tHigherPointReached
      
   else if pCurrentSet > tFarthestSet then // If we've just completed level 1 of a new set
      
      put pCurrentSet into tFarthestArray[1] // Update to the new set number
      put 1 into tFarthestArray[2]  // Update to level 1
      put true into tHigherPointReached
      
   end if
   
   if tHigherPointReached then // If we've reached a new further point in game, update the custom property to reflect this
      
      combine tFarthestArray using comma // Convert array so it can be viewing in the IDE as a custom property
      set the cFarthestPoint of this stack to tFarthestArray
      
   end if   
   
end updateProgress

## Calculates the level's star rating based on the level set's cStarRating custom property

function calculateStarRating
   
   put sLevelProperties["cStarRating"] into tStarRating // Get star rating parameters for level
   split tStarRating by return and ":" // Split into array
   
   if sMovesCounter <= tStarRating[3] then
      return 3 // 3-star rating
   else if sMovesCounter > tStarRating[3] and sMovesCounter <= tStarRating[2] then
      return 2 // 2-star rating
   else
      return 1 // 1-star rating
   end if

end calculateStarRating

on showWinCard
   
   stopGame
   go card "level_win" // Go to the success card
   
end showWinCard

function isAnimating
   
   // If the foot is in a mid-transit location, switch on the animation flag
   if sFoot1Loc["x"] <> item 1 of the loc of button "foot1" or sFoot1Loc["y"] <> item 2 of the loc of button "foot1" or sFoot2Loc["x"] <> item 1 of the loc of button "foot2" or sFoot2Loc["y"] <> item 2 of the loc of button "foot2" or sFoot3Loc["x"] <> item 1 of the loc of button "foot3" or sFoot3Loc["y"] <> item 2 of the loc of button "foot3" then
      return true
   else
      return false
   end if
   
end isAnimating

## Creates a pseudocard for each set of levels in the game

on createSet pSetNumber, pCardName, pPadding, pBtnDiameter, pDiv, pX, pY, pCustomPropertySets
   
   put 1 into tCount
   repeat for each line tProperty in pCustomPropertySets // Cycle through sets
      
      if "set" & pSetNumber is in tProperty then // If we find a level for this set
         
         put tProperty into tLevelsInSet[tCount] // Add it to array
         
         put tCount + 1 into tCount // tCount++
         
      end if
      
   end repeat
   
   // Add relevant number of buttons to page
   
   put the number of lines of (the keys of tLevelsInSet) into tLevelsArrayLength // Get array length
   
   copy group "set_template" of cd pCardName to group "all_sets" of cd pCardName // Clone the empty group we'll use as set for group (placing it in the parent group for all sets)
   put "set" & pSetNumber into tSetName
   set the name of it to tSetName // Set its name
   
   repeat with x = 1 to tLevelsArrayLength // Go through all levels in this set
      
      // Clone button and set dimensions and loc
      copy graphic "btn_bg" of cd pCardName to group tSetName of cd pCardName // Make a copy of button bg and add to set's group
      set the name of it to "btn_bg" & x
      set the width of it to pBtnDiameter
      set the height of it to pBtnDiameter
      set the loc of it to pX, pY
      copy fld "level_number" of cd pCardName to group tSetName of cd pCardName // Do the same for the field
      set the name of it to "level_number" & x
      set the width of it to pBtnDiameter
      set the height of it to pBtnDiameter
      set the loc of it to pX, pY
      put "level_number" & x into tFieldName
      put x into fld tFieldName of group tSetName of cd pCardName // Add level number to field
      
      put pX + pDiv into pX // Move along in row
      
      if pX > the width of cd pCardName - pPadding then // If we've come to the end of the row
         
         put (pDiv / 2) + pPadding into pX // Back to first column
         put pY + pBtnDiameter + pPadding into pY // Next row
         
      end if      
      
   end repeat
   
   // Add relevant level details to each button
   
   repeat with x = 1 to tLevelsArrayLength
      
      put true into tLocked // Set flag to true as default
      put "level_number" & x into tLevelField // Get name of field x
      set the cLevel of fld tLevelField of group tSetName of cd pCardName to x // Set the cLevel property to the corresponding level number. This will be used to go to the correct card when the button is tapped
      
      if pSetNumber < item 1 of the cFarthestPoint of the current stack then // If this is a set already fully completed
         put false into tLocked
      else if pSetNumber is item 1 of the cFarthestPoint of the current stack and x < item 2 of the cFarthestPoint of the current stack + 2 then // If this is the set to which player has progressed, and is before the level at which the player is now entitled to start the game
         put false into tLocked
      else if pSetNumber is sLastSetFullyCompleted + 1 and pSetNumber is item 1 of the cFarthestPoint of the current stack + 1 and x is 1 then // If this is the first level in the "next" set,  it should be unlocked
         put false into tLocked
      else if pSetNumber is 1 and x is 1 then // Set 1, Level 1 is always unlocked
         put false into tLocked
      end if
      
      if tLocked then // If this level is locked
         put "btn_bg" & x into tGraphicName
         set the opaque of graphic tGraphicName of group tSetName of cd pCardName to true // Set the opaque of the background graphic to full
         set the blendLevel of graphic tGraphicName of group tSetName of cd pCardName to 61 // Fade button bg
         set the blendLevel of fld tLevelField of group tSetName of cd pCardName to 28 // Fade button value
         set the cUnlocked of fld tLevelField of group tSetName of cd pCardName to false // Mark that this field is locked
      else // If the level is unlocked
         set the cUnlocked of fld tLevelField of group tSetName of cd pCardName to true // Mark that this field is unlocked
      end if
      
      if not tLocked and x is tLevelsArrayLength and pSetNumber < the cCurrentSet of this stack  then // If this is the last level in the set and it's not locked and we've already got to a higher set
         put pSetNumber into sLastSetFullyCompleted // Make this set the most recently fully completed one
      end if
      
   end repeat
   
end createSet

## Controls creation of set/level selection groups (panels allowing the user to select which level and set they'd like to play)

on configLevelSelectionCard pSetNumber
   
   // Setup
   put the cNumberOfSets of the current stack into tNumberOfSets // Get number of sets   
   put "level_select" into tCardName // Get level-selection card name   
   deleteControlsFromCard tCardName // Delete any pre-existing controls from level-selection card   
   
   repeat with tControl = 1 to the number of controls in cd "level_select_template" // Go through all controls in template card
      put the long name of control tControl of cd "level_select_template" into tControlName // Get control name     
      if "group" is in tControlName and word 1 of tControlName is "group" or "group" is not in tControlName then // Don't want to clone children of groups twice
         copy control tControl of cd "level_select_template" to cd tCardName // Copy them over to the relevant actual level selection card
      end if
   end repeat
   
   put the width of cd tCardName into tCardWidth // Get card width
   put round(tCardWidth / 7) into tPadding // Work out padding
   put tCardWidth - (tPadding * 2) into tCardWidth // New width of card minus padding
   put round(tCardWidth / 4.5) into tBtnDiameter // Calculate button diameter   
   put tCardWidth / 4 into tDiv // Width of 1/4 of card   
   put (tDiv / 2) + tPadding into tX // Work out starting point on X axis
   put (tDiv / 2) + tPadding into tY // And the Y
   
   put the customPropertySets of the current stack into tCustomPropertySets // Get stack custom property sets
   put 0 into sLastSetFullyCompleted // Reset tracker
   
   repeat with i = 1 to tNumberOfSets
      
      createSet i, tCardName, tPadding, tBtnDiameter, tDiv, tX, tY, tCustomPropertySets // Go create the set of levels
      
   end repeat
   
   positionSets tCardName, tCardWidth, tBtnDiameter // Position the newly created groups of sets
   set the visible of group "all_sets" of cd tCardName to false // Hide group of sets
   put the height of this card / 10 into tTopPos
   put the height of this card - round(tTopPos / 2) into tBottomPos
   set the loc of image "choose_a_level" of cd tCardName to item 1 of the loc of this card, tTopPos // Position card title
   
   // Position stop button
   set the left of group "stop_btn" of cd tCardName to item 1 of the loc of this card - (the width of group "stop_btn" of cd tCardName / 2)
   set the bottom of group "stop_btn" of cd tCardName to the bottom of this card - (the height of group "stop_btn" of cd tCardName / 2)
   
   set the visible of image "choose_a_level" of cd tCardName to false // Hide card title
   set the visible of group "stop_btn" of cd tCardName to false // Hide stop button
   
end configLevelSelectionCard

on positionSets pCardName, pCardWidth, pBtnDiameter
   
   local tNumberOfSets, tPrevGroupLocX, tPrevSetName, tSetName, tSet2GroupLocX, tDistanceBetweenLocs, tCurrentSet, tCurrentSetName, tCurrentSetLocX, tCardLocX, tDistanceToMove, tNewXLoc
   
   put the cNumberOfSets of the current stack into tNumberOfSets // Get number of sets
   
   repeat with i = 1 to tNumberOfSets
      
      if i is 1 then // Position first set
         
         set the loc of group "set1" of cd pCardName to the loc of this card
         
      else if i is 2 then // Position set 2       
         
         put item 1 of the loc of group "set1" of cd pCardName into tPrevGroupLocX // Get x loc of set 1         
         put "set" & i into tSetName // Get set name         
         set the left of group tSetName of cd pCardName to the right of cd pCardName - (pBtnDiameter / 2) // Position group so half of the first button of the next set is showing at the right of the card
         set the loc of group tSetName of cd pCardName to item 1 of the loc of group tSetName of cd pCardName, item 2 of the loc of this card // Deal with group's Y position
         put item 1 of the loc of group tSetName of cd pCardName into tSet2GroupLocX // Get x loc of set 2         
         put tSet2GroupLocX - tPrevGroupLocX into tDistanceBetweenLocs // Store distance between the locs of set 1 and set 2
         
      else
         
         put "set" & i - 1 into tPrevSetName // Get previous set's name
         put item 1 of the loc of group tPrevSetName of cd pCardName into tPrevGroupLocX // Get x loc of previous set's group         
         put "set" & i into tSetName // Get set name         
         set the loc of group tSetName of cd pCardName to tPrevGroupLocX + tDistanceBetweenLocs, item 2 of the loc of this card // Position group relative to previous
         
      end if
      
   end repeat
   
   // Position current set's group at the centre
   
   put the cCurrentSet of this stack into tCurrentSet
   put "set" & tCurrentSet into tCurrentSetName
   
   put item 1 of the loc of group tCurrentSetName of cd pCardName into tCurrentSetLocX // Where is current set's x loc?
   put item 1 of the loc of this card into tCardLocX // What is card's x loc?
   
   if tCurrentSetLocX is not tCardLocX then // If we're not on first set
      
      put tCurrentSetLocX - tCardLocX into tDistanceToMove // Work out how much we need to move to position current set centrally
      
      put item 1 of the loc of group "all_sets" of cd pCardName - tDistanceToMove into tNewXLoc
      set the loc of group "all_sets" of cd pCardName to tNewXLoc, item 2 of the loc of group "all_sets" of cd pCardName // Move sets' parent group so that current set's group is centered
      
   end if
   
end positionSets

on shutdown
   
   // Save level, prefs, score etc
   
end shutdown
