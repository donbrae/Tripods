local sStartUpdateTime
local sFrameRate
local sUpdateMessageId
local sCellWidth
local sFoot1Loc
local sFoot2Loc
local sFoot3Loc
local sPivotLoc

local sFootPivotCount // Keep track of how many feet have moved in pivot move (animation happens asynchronously and AE only offers a single callback out of the box)

local sFootLanding1Locs // Array of the loc(s) that foot 1 needs to be at to win
local sFootLanding2Locs
local sFootLanding3Locs

local sMovesCounter
local sTotalMoves

global gLevel
local sLastLevelCompleted

local sJumpAnimateSpeed
local sPivotAnimateSpeed
local sAnimating
local sCurrentAnimation // Pivot or jump
local sCollision

## Stack custom properties: 
// accelleratedRendering

on preOpenStack
   set the accelleratedRendering of this stack to true
   set the defaultFolder to specialFolderPath("documents") // Where we write files to (good for iOS and Mac OS X)
   start using stack "Helper"
end preOpenStack

on openStack
   
   if "animationEngine" is not among the lines of the stacksInUse then
      start using stack "animationEngine"
   end if
   
   if there is a file "moves.txt" then
      put URL ("file:moves.txt") into sTotalMoves // Get total moves used from file and store in script local
   else
      put 10000 into sTotalMoves // If no file, then put to 10000
   end if
   
   retrieveHighScores
   
   
end openStack

on closeStack
   
   put sTotalMoves into URL ("file:moves.txt") // Store number of moves remaining   
   saveHighScores
   
end closeStack

on saveHighScores
   
   // Get high scores custom property as an array
   put the customProperties["cHighScores"] of the current stack into tHighScores
   
   // Cycle through the array and format for saving to file
   repeat for each line tKey in the keys of tHighScores
      put tKey & ":" & tHighScores[tKey] & return after tArrayContents
   end repeat
   
   put tArrayContents into URL ("file:highscores.txt") // Save to file
   
end saveHighScores

## Read high scores from file
on retrieveHighScores
   
   if there is a file "highscores.txt" then      
      put URL ("file:highscores.txt") into tHighScores // Get text file   
      split tHighScores by return and ":" // Split into array   
      set the customProperties["cHighScores"] of this stack to tHighScores // Set the array to value of cHighScores custom property
   end if   
   
end retrieveHighScores

on setupLevel
   
   put the width of button "grid" / 8 into sCellWidth
   put sCellWidth / 2 + the left of button "grid" into tX -- +1 for grid border
   put sCellWidth / 2 + the top of button "grid" into tY   
   put the cLevelData["elPlacement"] of the current cd into tElPlacement
   
   repeat for each line l in tElPlacement -- Cycle through each line
      
      repeat for each item el in l -- Cycle through each cell
         
         ## Check button type
         if el is 4 then -- Block
            clone button "block_src"
            set the name of it to "block"
         else if el is 1 then -- Foot 1
            clone button "foot1_src"
            set the name of it to "foot1"
            set the class of it to "foot"
         else if el is 2 then -- Foot 2
            clone button "foot2_src"
            set the name of it to "foot2"
            set the class of it to "foot"
         else if el is 3 then -- Foot 3
            clone button "foot3_src"
            set the name of it to "foot3"
            set the class of it to "foot"
         else if el is 5 then -- Landing 1
            clone button "landing1_src"
            set the name of it to "landing1"
            set the class of it to "landing"
         else if el is 6 then -- Landing 2
            clone button "landing2_src"
            set the name of it to "landing2"
            set the class of it to "landing"
         else if el is 7 then -- Landing 3
            clone button "landing3_src"
            set the name of it to "landing3"
            set the class of it to "landing"
         else if el is 8 then -- Pivot
            clone button "pivot_src"
            set the name of it to "pivot"
            set the visible of it to false
         end if
         
         if el is not 0 then
            set the loc of the last button to tX,tY -- Place button on grid
         end if
         
         put tX + sCellWidth into tX -- Next cell
         
      end repeat 
      
      put sCellWidth / 2 + the top of button "grid" into tX -- Back to beginning of row
      put tY + sCellWidth into tY -- Next row
      
   end repeat  
   
   // Clone shadow buttons for detecting collisons during pivots
   clone button "shadowFoot1_src"
   set the name of it to "shadowFoot1"
   set the class of it to "shadowFoot"
   clone button "shadowFoot2_src"
   set the name of it to "shadowFoot2"
   set the class of it to "shadowFoot"
   clone button "shadowFoot3_src"
   set the name of it to "shadowFoot3"
   set the class of it to "shadowFoot"
   
   ## Clone other bits of UI
   
   // Bring sprite to top
   set the layer of btn "foot3" to top
   set the layer of btn "foot2" to top
   set the layer of btn "foot1" to top
   set the layer of btn "pivot" to top
   
   ## Store the starting positions of the feet
   
   put item 1 of the loc of btn "foot1" into sFoot1Loc["x"] // X
   put item 2 of the loc of btn "foot1" into sFoot1Loc["y"] // Y
   
   put item 1 of the loc of btn "foot2" into sFoot2Loc["x"]
   put item 2 of the loc of btn "foot2" into sFoot2Loc["y"]
   
   put item 1 of the loc of btn "foot3" into sFoot3Loc["x"]
   put item 2 of the loc of btn "foot3" into sFoot3Loc["y"]
   
   ## Store pivot position
   
   put the loc of btn "pivot" into sPivotLoc
   
   ## Set various level values
   
   put false into sChangeInFootPos
   put 500 into sJumpAnimateSpeed // Speed in ms jump
   put 230 into sPivotAnimateSpeed // Speed in ms jump
   put false into sAnimating // Boolean set to true when elements are being moved
   put 0 into sMovesCounter // Reset move counter
   put false into sCollision // Set collision flag to false
   put empty into sFootLandingLocs // Empty target foot location array
   set the label of button "moves_value" to sMovesCounter // Amend moves counter
   
   ## Calculate landing locs
   
   repeat with tControl = 1 to the number of controls in current card // Go through all card controls
      
      if the class of control tControl is "foot" then // If the control is a foot
         put the landOn of control tControl into tLanding // Get the landOn custom property, which tells us which landing cells the feet can land on to win the level
         put 1 into tCount
         put empty into tTempLocsStore
         put the short name of control tControl into tButtonName // Get short name of button
         
         put empty into tArray // Temporary array
         
         repeat for each line tValue in tLanding // Go through each value in property
            put the loc of btn tValue into tArray[tCount] // Add the locs of the corresponding landing foot into the script array
            put tCount + 1 into tCount
         end repeat
         
         // Populate script arrays for target locations
         if tButtonName is "foot1" then
            put tArray into sFootLanding1Locs
         else if tButtonName is "foot2" then
            put tArray into sFootLanding2Locs
         else if tButtonName is "foot3" then
            put tArray into sFootLanding3Locs
         end if 
         
      end if
   end repeat
   
   set the label of button "number_moves_remaining" to sTotalMoves
   
end setupLevel

// Hide the sprite

on hideSprite
   set the vis of button "foot1" to false
   set the vis of button "foot2" to false
   set the vis of button "foot3" to false
end hideSprite

// Flash the sprite

on aeWrapper pAEFunc, pMilliSecs
   
   if pAEFunc is "fadeIn" then
      aeLockMoves
      aeFadeIn the long id of btn "foot1",pMilliSecs
      aeFadeIn the long id of btn "foot2",pMilliSecs
      aeFadeIn the long id of btn "foot3",pMilliSecs
      aeUnlockMoves
   end if
   
   if pAEFunc is "fadeOut" then
      aeLockMoves
      aeFadeOut the long id of btn "foot1",pMilliSecs
      aeFadeOut the long id of btn "foot2",pMilliSecs
      aeFadeOut the long id of btn "foot3",pMilliSecs
      aeUnlockMoves
   end if
   
end aeWrapper

on flashSprite
   
   put 200 into flashSpeed
   
   // Flash pivot
   put the long ID of btn "pivot" into tPivot
   send "aefadeIn tPivot, flashSpeed" to me in 750 millisecs
   
   // Flash feet   
   send "aeWrapper fadeIn, flashSpeed" to me in 450 millisecs
   send "aeWrapper fadeIn, flashSpeed" to me in 750 millisecs
   
end flashSprite

on clearLevel
   
   // Delete level objects from card
   put the number of buttons of this card into tCount
   repeat with x = tCount down to 1
        if the class of button x of this card is "foot" or the class of button x of this card is "landing" or the class of button x of this card is "shadowFoot" or the short name of button x of this card is "block" or the short name of button x of this card is "pivot" then
             delete button x of this card
        end if
   end repeat
   
end clearLevel
   
on activateScreenUpdates
   
   stopUpdatingTheScreen
   startUpdatingTheScreen 60
   
end activateScreenUpdates

on startUpdatingTheScreen pFrameRate
   put pFrameRate into sFrameRate
   put 0 into sStartUpdateTime
   send "dispatchUpdateScreen" to me in 0 millisecs
   put the result into sUpdateMessageId
end startUpdatingTheScreen

on stopUpdatingTheScreen
   if sUpdateMessageId is not empty then
      cancel sUpdateMessageId
   end if
   put empty into sUpdateMessageId
end stopUpdatingTheScreen

on dispatchUpdateScreen
   local tThisFrameTime
   put the long seconds into tThisFrameTime
   
   if sStartUpdateTime is 0 then
      put the long seconds into sStartUpdateTime
   end if
   
   lock screen
   dispatch "updateScreen" to this card with tThisFrameTime
   unlock screen
   
   local tTheTimeNow
   put the long seconds into tTheTimeNow
   
   local tNextFrameCount
   put round((tTheTimeNow - sStartUpdateTime) * sFrameRate + 0.5) into tNextFrameCount
   send "dispatchUpdateScreen" to me in (sStartUpdateTime + (tNextFrameCount * (1 / sFrameRate)) - tTheTimeNow) seconds
   put the result into sUpdateMessageId
end dispatchUpdateScreen

local sGameRunning

###

on preOpenStack
   put "preOpenStack" into message box
end preOpenStack

on startGame
   
   put gLevel into msg box
   
   activateScreenUpdates
   put true into sGameRunning 
   flashSprite
   
end startGame

on stopGame
   
   put false into sGameRunning
   
end stopGame

on endGame
   
   -- move button "foot1" to 256,218 in 10 ticks
   
   put 0 into sMovesCounter
   
   //set the label of button "number_moves_remaining" to sTotalMoves
   set the label of button "moves_value" to sMovesCounter
   
   put false into sGameRunning
   
end endGame

on incrMoves
   
   put sMovesCounter + 1 into sMovesCounter // sMovesCounter++
   set the label of button "moves_value" to sMovesCounter // Amend moves counter
   
   put sTotalMoves - 1 into sTotalMoves // sTotalMoves--
   set the label of button "number_moves_remaining" to sTotalMoves // Amend total moves counter
    
end incrMoves

on goJump pX, pY, pPivotX, pPivotY, pFootShortName
   
   put false into tBoundaryHit
   put the loc of button pFootShortName into tPreMoveFootPos
   
   // Get coords of grid boundary
   put the top of button "grid" into tGridTop
   put the bottom of button "grid" into tGridBottom
   put the left of button "grid" into tGridLeft
   put the right of button "grid" into tGridRight
   
   if pY < tGridTop or pY > tGridBottom or pX < tGridLeft or pX > tGridRight then // If game area boundary will be hit
      
      put true into tBoundaryHit
      
      // Amend pX and pY parameters
      if pY < tGridTop then
         put tGridTop + (sCellWidth / 2) into pY
      else if pY > tGridBottom then
         put tGridBottom - (sCellWidth / 2) into pY
      else if pX > tGridRight then
         put tGridRight - (sCellWidth / 2) into pX
      else if pX < tGridLeft then
         put tGridLeft + (sCellWidth / 2) into pX
      end if
      
   end if  
   
   put "overshoot" into tJumpEffect // Default jump easing effect
   
   put item 1 of tPreMoveFootPos into tFootPrevX // Get X coord of previous foot loc
   put item 2 of tPreMoveFootPos into tFootPrevY // Get Y coord of previous foot loc
   
   if tBoundaryHit then // If a boundary has been hit
      
      put "bounce" into tEffect      
      
      // Get mid-point between other two feet
      if pFootShortName is "foot1" then
         put getMidPoint(the loc of btn "foot2", the loc of btn "foot3") into tMidPoint
      else if pFootShortName is "foot2" then
         put getMidPoint(the loc of btn "foot1", the loc of btn "foot3") into tMidPoint
      else if pFootShortName is "foot3" then
         put getMidPoint(the loc of btn "foot1", the loc of btn "foot2") into tMidPoint
      end if
      
      // Fade out pivot
      put the long ID of btn "pivot" into tPivot      
      send "aeFadeOut tPivot, 100" to me in 1 millisecs
  
      aeMoveTo the long id of btn pFootShortName, item 1 of tMidPoint, item 2 of tMidPoint, sJumpAnimateSpeed / 3.5, "" // Move to boundary
      send "jumpBack pFootShortName, tFootPrevX, tFootPrevY, tEffect" to btn pFootShortName in 200 milliseconds // Jump back after wait
      send "aeFadeIn tPivot, 150" to me in 300 millisecs // Fade pivot back in
            
   else // Otherwise, move to new position
      
      // Fade out pivot
      put the long ID of btn "pivot" into tPivot      
      send "aeFadeOut tPivot, 100" to me in 1 millisecs
            
      animateFoot pFootShortName
      
      aeLockMoves
      aeMoveTo the long id of btn pFootShortName,pX,pY,sJumpAnimateSpeed,tJumpEffect
      aeUnlockMoves
           
   end if
   
   // Detect collision with block
   set the loc of btn "shadowFoot1" to pX,pY // Set position of a shadow foot to check for imminent collisions  
   put detectCollision() into tJumpCollide
   
   if tJumpCollide and not tBoundaryHit then // If the foot will jump onto a block
      put "jumpFail" into sCurrentAnimation
      put "overshoot" into tEffect
      send "jumpBack pFootShortName, tFootPrevX, tFootPrevY, tEffect" to btn pFootShortName in 700 milliseconds // Call jumpBack() after a short interval
      send "aeFadeIn tPivot, 150" to me in 1000 millisecs // Fade pivot back in
   end if
   
   if not tBoundaryHit and not tJumpCollide then // If a boundary hasn't been hit, or the foot hasn't jumped onto a block
      
      send "aeFadeIn tPivot, 150" to me in sJumpAnimateSpeed millisecs
      
      send "incrMoves" to this card in sJumpAnimateSpeed milliseconds // Increment moves counter
      
      //aeMoveTo the long id of btn "pivot", pPivotX,pPivotY,sJumpAnimateSpeed // Move pivot
      
      if pFootShortName is "foot1" then // Update script-level loc for relevant foot
         put pX into sFoot1Loc["x"]
         put pY into sFoot1Loc["y"]
      else if pFootShortName is "foot2" then
         put pX into sFoot2Loc["x"]
         put pY into sFoot2Loc["y"]
      else if pFootShortName is "foot3" then
         put pX into sFoot3Loc["x"]
         put pY into sFoot3Loc["y"]
      end if
   end if
   
end goJump

on adjustPivot
   
end adjustPivot

## Animates lift and drop of foot

on goAnimate pFootShortName, imageID
   set the icon of btn pFootShortName to imageID
end goAnimate

## Control animation for lift and drop of foot

on animateFoot pFootShortName
   
   put the imgGrp of btn pFootShortName into tImgGrpID // Get the ID of the image group which corresponds with this foot
   put the anim of group id tImgGrpID of card "elements" into tAnimImages // Get the anim custom property of the group (in the "elements" card). This lists the images which will be used in the animation
   
   put round(sJumpAnimateSpeed / 12) into tAnimInc // Calculate a 'frame rate'
   put 1 into tMultiplier
   
   // Do the animation
   repeat for each line tImgID in tAnimImages
      send "goAnimate pFootShortName, tImgID" to btn pFootShortName in tAnimInc * tMultiplier milliseconds
      put tMultiplier + 1 into tMultiplier
   end repeat
   
end animateFoot

on repositionPivot
   
   // Get angles of foot one to other two feet
   put the loc of btn "foot1" into tFoot1
   put the loc of btn "foot2" into tFoot2
   put the loc of btn "foot3" into tFoot3
   
   put getAngleBetweenPoints(tFoot1, tFoot2) into tAngle12
   put getAngleBetweenPoints(tFoot1, tFoot3) into tAngle13
   
   put round(sCellWidth / 6) into tPivotShift // The pivot will be moved by slightly more than the cell width
   
   ## For clockwise arrangement 1, 2, 3
   
   if tAngle12 is 63 and tAngle13 is 117 then // Position 1
      put item 1 of tFoot1 into tPivotX
      put item 2 of tFoot1 + sCellWidth + tPivotShift into tPivotY
      
   else if tAngle12 is 90 and tAngle13 is 153 then // Position 2
      put item 2 of tFoot3 into tPivotY
      put item 1 of tFoot3 + sCellWidth + tPivotShift into tPivotX
      
   else if tAngle12 is 117 and tAngle13 is 180 then // Position 3
      put item 1 of tFoot2 into tPivotX
      put item 2 of tFoot2 - sCellWidth - tPivotShift into tPivotY
      
   else if tAngle12 is 153 and tAngle13 is -153 then // Position 4
      put item 2 of tFoot1 into tPivotY
      put item 1 of tFoot1 - sCellWidth - tPivotShift into tPivotX
      
   else if tAngle12 is 180 and tAngle13 is -117 then // Position 5
      put item 1 of tFoot3 into tPivotX
      put item 2 of tFoot3 + sCellWidth + tPivotShift into tPivotY
      
   else if tAngle12 is -153 and tAngle13 is -90 then // Position 6
      put item 2 of tFoot2 into tPivotY
      put item 1 of tFoot2 + sCellWidth + tPivotShift into tPivotX
      
   else if tAngle12 is -117 and tAngle13 is -63 then // Position 7
      put item 1 of tFoot1 into tPivotX
      put item 2 of tFoot1 - sCellWidth - tPivotShift into tPivotY
      
   else if tAngle12 is -90 and tAngle13 is -27 then // Position 8
      put item 2 of tFoot3 into tPivotY
      put item 1 of tFoot3 - sCellWidth - tPivotShift into tPivotX
      
   else if tAngle12 is -63 and tAngle13 is 0 then // Position 9
      put item 1 of tFoot2 into tPivotX
      put item 2 of tFoot2 + sCellWidth + tPivotShift into tPivotY
      
   else if tAngle12 is -27 and tAngle13 is 27 then // Position 10
      put item 2 of tFoot1 into tPivotY
      put item 1 of tFoot1 + sCellWidth + tPivotShift into tPivotX
      
   else if tAngle12 is 0 and tAngle13 is 63 then // Position 11
      put item 1 of tFoot3 into tPivotX
      put item 2 of tFoot3 - sCellWidth - tPivotShift into tPivotY
      
   else if tAngle12 is 27 and tAngle13 is 90 then // Position 12
      put item 2 of tFoot2 into tPivotY
      put item 1 of tFoot2 - sCellWidth - tPivotShift into tPivotX
      
   else if tAngle13 is 63 and tAngle12 is 117 then // Position 1 (clockwise 1, 3, 2)         
      put item 1 of tFoot1 into tPivotX
      put item 2 of tFoot1 + sCellWidth + tPivotShift into tPivotY
      
   else if tAngle13 is 90 and tAngle12 is 153 then // Position 2
      put item 2 of tFoot2 into tPivotY
      put item 1 of tFoot2 + sCellWidth + tPivotShift into tPivotX
      
   else if tAngle13 is 117 and tAngle12 is 180 then // Position 3
      put item 1 of tFoot3 into tPivotX
      put item 2 of tFoot3 - sCellWidth - tPivotShift into tPivotY
      
   else if tAngle13 is 153 and tAngle12 is -153 then // Position 4
      put item 2 of tFoot1 into tPivotY
      put item 1 of tFoot1 - sCellWidth - tPivotShift into tPivotX
      
   else if tAngle13 is 180 and tAngle12 is -117 then // Position 5
      put item 1 of tFoot2 into tPivotX
      put item 2 of tFoot2 + sCellWidth + tPivotShift into tPivotY
      
   else if tAngle13 is -153 and tAngle12 is -90 then // Position 6
      put item 2 of tFoot3 into tPivotY
      put item 1 of tFoot3 + sCellWidth + tPivotShift into tPivotX
      
   else if tAngle13 is -117 and tAngle12 is -63 then // Position 7
      put item 1 of tFoot1 into tPivotX
      put item 2 of tFoot1 - sCellWidth - tPivotShift into tPivotY
      
   else if tAngle13 is -90 and tAngle12 is -27 then // Position 8
      put item 2 of tFoot2 into tPivotY
      put item 1 of tFoot2 - sCellWidth - tPivotShift into tPivotX
      
   else if tAngle13 is -63 and tAngle12 is 0 then // Position 9
      put item 1 of tFoot3 into tPivotX
      put item 2 of tFoot3 + sCellWidth + tPivotShift into tPivotY
      
   else if tAngle13 is -27 and tAngle12 is 27 then // Position 10
      put item 2 of tFoot1 into tPivotY
      put item 1 of tFoot1 + sCellWidth + tPivotShift into tPivotX
      
   else if tAngle13 is 0 and tAngle12 is 63 then // Position 11
      put item 1 of tFoot2 into tPivotX
      put item 2 of tFoot2 - sCellWidth - tPivotShift into tPivotY
      
   else if tAngle13 is 27 and tAngle12 is 90 then // Position 12
      put item 2 of tFoot3 into tPivotY
      put item 1 of tFoot3 - sCellWidth - tPivotShift into tPivotX
   else
      // Just a bit of defensive programming for the pivot to stay still if none of the above conditions is met (so tPivotX and tPivotY have a value) 
      put item 1 of the loc of btn "pivot" into tPivotX
      put item 2 of the loc of btn "pivot" into tPivotY
   end if
   
   put tPivotX,tPivotY into sPivotLoc
   
   if the loc of btn "pivot" is not sPivotLoc and sCurrentAnimation is "pivot" then // If the pivot needs to change location after a pivot move
      put the long ID of btn "pivot" into tPivot
      send "aeMoveTo tPivot, item 1 of sPivotLoc, item 2 of sPivotLoc, 200" to me in 1 millisecs
   else if the loc of btn "pivot" is not sPivotLoc and sCurrentAnimation is "jump" then // If the pivot needs to change location after a jump
      set the loc of btn "pivot" to sPivotLoc // Set new loc right away
   end if
   
end repositionPivot
   
on jump pFootLoc, pFootShortName
   
   put the visible of btn "pivot" into msg box
   
   if not sAnimating then
      
      resetShowFeet
      
      put "jump" into sCurrentAnimation
      
      put 1 into tFootCount
      // Cycle through all feet
      repeat with tControl = 1 to the number of controls in current card // Go through all card controls
         
         if the class of control tControl is "foot" then // If the control is a foot
            
            put "foot" & tFootCount into tFoot
            put the loc of button tFoot into tFootLoc // Get the location of this foot
            
            if tFootLoc is not pFootLoc then // If this isn't the foot we've swiped
               put tFootLoc into tOtherFeetLocs[tFootCount] // Store the coordinates of this foot
            end if
            
            put tFootCount + 1 into tFootCount
         end if
         
      end repeat
      
      put 1 into tCount
      repeat for each element tElement in tOtherFeetLocs // For each of the other two foot locations
         put getAngleBetweenPoints(pFootLoc, tElement) into tAngles[tCount] // Get the angle between the swiped foot and the location of the other foot
         put tCount + 1 into tCount
      end repeat
      
      put item 1 of the loc of button pFootShortName into tX // Get current x pos of the swiped foot
      put item 2 of the loc of button pFootShortName into tY // Get current y pos of the swiped foot
      put item 1 of the loc of button "pivot" into tPivotX // Get current x pos of the pivot
      put item 2 of the loc of button "pivot" into tPivotY // Get current y pos of the pivot      
          
      // Read angles and work out in which direct the foot needs to jump
      if tAngles[1] is -117 and tAngles[2] is -63 or tAngles[2] is -117 and tAngles[1] is -63 then // N    
         put tY - (sCellWidth * 4) into tY // Amend the y pos of swiped foot
         //put tPivotY - (sCellWidth * 2) into tPivotY // Amend the y pos of pivot
      else if tAngles[1] is -27 and tAngles[2] is 27 or tAngles[2] is -27 and tAngles[1] is 27 then // E
         put tX + (sCellWidth * 4) into tX
         //put tPivotX + (sCellWidth * 2) into tPivotX
      else if tAngles[1] is 117 and tAngles[2] is 63 or tAngles[2] is 117 and tAngles[1] is 63 then // S      
         put tY + (sCellWidth * 4) into tY 
         //put tPivotY + (sCellWidth * 2) into tPivotY
      else if tAngles[1] is -153 and tAngles[2] is 153 or tAngles[2] is -153 and tAngles[1] is 153 then // W
         put tX - (sCellWidth * 4) into tX 
         //put tPivotX - (sCellWidth * 2) into tPivotX
      else if tAngles[1] is -117 and tAngles[2] is 180 or tAngles[2] is -117 and tAngles[1] is 180 then // NW
         put tY - (sCellWidth * 2) into tY
         put tX - (sCellWidth * 3) into tX
         //put tPivotX - sCellWidth into tPivotX
      else if tAngles[1] is -153 and tAngles[2] is -90 or tAngles[2] is -153 and tAngles[1] is -90 then // NNW    
         put tY - (sCellWidth * 3) into tY
         put tX - (sCellWidth * 2) into tX
         //put tPivotY - sCellWidth into tPivotY
      else if tAngles[1] is 0 and tAngles[2] is -63 or tAngles[2] is 0 and tAngles[1] is -63 then // NE
         put tY - (sCellWidth * 2) into tY
         put tX + (sCellWidth * 3) into tX
         //put tPivotX + sCellWidth into tPivotX
      else if tAngles[1] is -90 and tAngles[2] is -27 or tAngles[2] is -90 and tAngles[1] is -27 then // NNE    
         put tY - (sCellWidth * 3) into tY
         put tX + (sCellWidth * 2) into tX
         //put tPivotY - sCellWidth into tPivotY
      else if tAngles[1] is 0 and tAngles[2] is 63 or tAngles[2] is 0 and tAngles[1] is 63 then // SE
         put tY + (sCellWidth * 2) into tY
         put tX + (sCellWidth * 3) into tX
         //put tPivotX + sCellWidth into tPivotX
      else if tAngles[1] is 90 and tAngles[2] is 27 or tAngles[2] is 90 and tAngles[1] is 27 then // SSE    
         put tY + (sCellWidth * 3) into tY
         put tX + (sCellWidth * 2) into tX
         //put tPivotY + sCellWidth into tPivotY
      else if tAngles[1] is 117 and tAngles[2] is 180 or tAngles[2] is 117 and tAngles[1] is 180 then // SW    
         put tY + (sCellWidth * 2) into tY
         put tX - (sCellWidth * 3) into tX
         //put tPivotX - sCellWidth into tPivotX
      else if tAngles[1] is 153 and tAngles[2] is 90 or tAngles[2] is 153 and tAngles[1] is 90 then // SSW    
         put tY + (sCellWidth * 3) into tY
         put tX - (sCellWidth * 2) into tX
         //put tPivotY + sCellWidth into tPivotY
      end if
      
      goJump tX, tY, tPivotX, tPivotY, pFootShortName // Do the jump, passing in the new x and y coords of the swiped foot and pivot, and the foot name
   end if
end jump

on resetShowFeet
   set the loc of btn "shadowFoot1" to 0,0
   set the loc of btn "shadowFoot2" to 0,0
   set the loc of btn "shadowFoot3" to 0,0
end resetShowFeet

on pivot
   if not sAnimating then // If no element is currently being animated
      
      resetShowFeet
      
      put "pivot" into sCurrentAnimation
      
      put the loc of btn "foot1" into tLastStationaryPos1
      put the loc of btn "foot2" into tLastStationaryPos2
      put the loc of btn "foot3" into tLastStationaryPos3
      
      split tLastStationaryPos1 by ","
      split tLastStationaryPos2 by ","
      split tLastStationaryPos3 by ","     
      
      put getAngleBetweenPoints(the loc of button "foot1", the loc of button "foot2") into tAngle12
      put getAngleBetweenPoints(the loc of button "foot1", the loc of button "foot3") into tAngle13
      
      ## For clockwise arrangement 1, 2, 3
      
      if tAngle12 is 63 and tAngle13 is 117 then // Position 1
         put sFoot1Loc["x"] + sCellWidth into sFoot1Loc["x"] // Move foot 1 to the right
         put sFoot3Loc["y"] - sCellWidth into sFoot3Loc["y"] // Move foot 3 up
         
      else if tAngle12 is 90 and tAngle13 is 153 then // Position 2
         put sFoot2Loc["x"] - sCellWidth into sFoot2Loc["x"] // Foot 2 left
         put sFoot3Loc["y"] - sCellWidth into sFoot3Loc["y"] // Foot 3 up 
         
      else if tAngle12 is 117 and tAngle13 is 180 then // Position 3
         put sFoot2Loc["x"] - sCellWidth into sFoot2Loc["x"] // Foot 2 left
         put sFoot1Loc["y"] + sCellWidth into sFoot1Loc["y"] // Foot 1 down 
         
      else if tAngle12 is 153 and tAngle13 is -153 then // Position 4
         put sFoot3Loc["x"] + sCellWidth into sFoot3Loc["x"] // Foot 3 right
         put sFoot1Loc["y"] + sCellWidth into sFoot1Loc["y"] // Foot 1 down
         
      else if tAngle12 is 180 and tAngle13 is -117 then // Position 5
         put sFoot3Loc["x"] + sCellWidth into sFoot3Loc["x"] // Foot 3 right
         put sFoot2Loc["y"] - sCellWidth into sFoot2Loc["y"] // Foot 2 up
         
      else if tAngle12 is -153 and tAngle13 is -90 then // Position 6
         put sFoot1Loc["x"] - sCellWidth into sFoot1Loc["x"] // Foot 1 left
         put sFoot2Loc["y"] - sCellWidth into sFoot2Loc["y"] // Foot 2 up
         
      else if tAngle12 is -117 and tAngle13 is -63 then // Position 7
         put sFoot1Loc["x"] - sCellWidth into sFoot1Loc["x"] // Foot 1 left
         put sFoot3Loc["y"] + sCellWidth into sFoot3Loc["y"] // Foot 3 down
         
      else if tAngle12 is -90 and tAngle13 is -27 then // Position 8
         put sFoot2Loc["x"] + sCellWidth into sFoot2Loc["x"] // Foot 2 right
         put sFoot3Loc["y"] + sCellWidth into sFoot3Loc["y"] // Foot 3 down
         
      else if tAngle12 is -63 and tAngle13 is 0 then // Position 9
         put sFoot2Loc["x"] + sCellWidth into sFoot2Loc["x"] // Foot 2 right
         put sFoot1Loc["y"] - sCellWidth into sFoot1Loc["y"] // Foot 1 up
         
      else if tAngle12 is -27 and tAngle13 is 27 then // Position 10
         put sFoot3Loc["x"] - sCellWidth into sFoot3Loc["x"] // Foot 3 left
         put sFoot1Loc["y"] - sCellWidth into sFoot1Loc["y"] // Foot 1 up
         
      else if tAngle12 is 0 and tAngle13 is 63 then // Position 11
         put sFoot3Loc["x"] - sCellWidth into sFoot3Loc["x"] // Foot 3 left
         put sFoot2Loc["y"] + sCellWidth into sFoot2Loc["y"] // Foot 2 down
         
      else if tAngle12 is 27 and tAngle13 is 90 then // Position 12
         put sFoot1Loc["x"] + sCellWidth into sFoot1Loc["x"] // Foot 1 right
         put sFoot2Loc["y"] + sCellWidth into sFoot2Loc["y"] // Foot 2 down        
         
      else if tAngle13 is 63 and tAngle12 is 117 then // Position 1 (clockwise 1, 3, 2)
         put sFoot1Loc["x"] + sCellWidth into sFoot1Loc["x"] // Move foot 1 to the right
         put sFoot2Loc["y"] - sCellWidth into sFoot2Loc["y"] // Move foot 2 up     
         
      else if tAngle13 is 90 and tAngle12 is 153 then // Position 2
         put sFoot3Loc["x"] - sCellWidth into sFoot3Loc["x"] // Foot 3 left
         put sFoot2Loc["y"] - sCellWidth into sFoot2Loc["y"] // Foot 2 up
         
      else if tAngle13 is 117 and tAngle12 is 180 then // Position 3
         put sFoot3Loc["x"] - sCellWidth into sFoot3Loc["x"] // Foot 3 left
         put sFoot1Loc["y"] + sCellWidth into sFoot1Loc["y"] // Foot 1 down 
         
      else if tAngle13 is 153 and tAngle12 is -153 then // Position 4
         put sFoot2Loc["x"] + sCellWidth into sFoot2Loc["x"] // Foot 2 right
         put sFoot1Loc["y"] + sCellWidth into sFoot1Loc["y"] // Foot 1 down
         
      else if tAngle13 is 180 and tAngle12 is -117 then // Position 5
         put sFoot2Loc["x"] + sCellWidth into sFoot2Loc["x"] // Foot 2 right
         put sFoot3Loc["y"] - sCellWidth into sFoot3Loc["y"] // Foot 3 up
         
      else if tAngle13 is -153 and tAngle12 is -90 then // Position 6
         put sFoot1Loc["x"] - sCellWidth into sFoot1Loc["x"] // Foot 1 left
         put sFoot3Loc["y"] - sCellWidth into sFoot3Loc["y"] // Foot 3 up
         
      else if tAngle13 is -117 and tAngle12 is -63 then // Position 7
         put sFoot1Loc["x"] - sCellWidth into sFoot1Loc["x"] // Foot 1 left
         put sFoot2Loc["y"] + sCellWidth into sFoot2Loc["y"] // Foot 2 down
         
      else if tAngle13 is -90 and tAngle12 is -27 then // Position 8
         put sFoot3Loc["x"] + sCellWidth into sFoot3Loc["x"] // Foot 3 right
         put sFoot2Loc["y"] + sCellWidth into sFoot2Loc["y"] // Foot 2 down
         
      else if tAngle13 is -63 and tAngle12 is 0 then // Position 9
         put sFoot3Loc["x"] + sCellWidth into sFoot3Loc["x"] // Foot 3 right
         put sFoot1Loc["y"] - sCellWidth into sFoot1Loc["y"] // Foot 1 up
         
      else if tAngle13 is -27 and tAngle12 is 27 then // Position 10
         put sFoot2Loc["x"] - sCellWidth into sFoot2Loc["x"] // Foot 2 left
         put sFoot1Loc["y"] - sCellWidth into sFoot1Loc["y"] // Foot 1 up
         
      else if tAngle13 is 0 and tAngle12 is 63 then // Position 11
         put sFoot2Loc["x"] - sCellWidth into sFoot2Loc["x"] // Foot 2 left
         put sFoot3Loc["y"] + sCellWidth into sFoot3Loc["y"] // Foot 3 down
         
      else if tAngle13 is 27 and tAngle12 is 90 then // Position 12
         put sFoot1Loc["x"] + sCellWidth into sFoot1Loc["x"] // Foot 1 right
         put sFoot3Loc["y"] + sCellWidth into sFoot3Loc["y"] // Foot 3 down
         
      end if
      
      // Move feet
      put sFoot1Loc["x"] into tFoot1x
      put sFoot1Loc["y"] into tFoot1y
      set the loc of btn "shadowFoot1" to tFoot1x,tFoot1y // Set shadow foot to check for imminent collisions
      
      put sFoot2Loc["x"] into tFoot2x
      put sFoot2Loc["y"] into tFoot2y
      set the loc of btn "shadowFoot2" to tFoot2x,tFoot2y
      
      put sFoot3Loc["x"] into tFoot3x
      put sFoot3Loc["y"] into tFoot3y
      set the loc of btn "shadowFoot3" to tFoot3x,tFoot3y     
      
      if detectCollision() then // If collision
         
         // Put back values of feet positions - we won't be pivoting
         put item 1 of the loc of btn "foot1" into sFoot1Loc["x"]
         put item 2 of the loc of btn "foot1" into sFoot1Loc["y"]
         put item 1 of the loc of btn "foot2" into sFoot2Loc["x"]
         put item 2 of the loc of btn "foot2" into sFoot2Loc["y"]
         put item 1 of the loc of btn "foot3" into sFoot3Loc["x"]
         put item 2 of the loc of btn "foot3" into sFoot3Loc["y"]
         
         // Nudge feet
         nudge "foot1", tFoot1x, tFoot1y, sFoot1Loc["x"], sFoot1Loc["y"]
         nudge "foot2", tFoot2x, tFoot2y, sFoot2Loc["x"], sFoot2Loc["y"]
         nudge "foot3", tFoot3x, tFoot3y, sFoot3Loc["x"], sFoot3Loc["y"]
         
      else if the visible of btn "pivot" then // If no collision and pivot is visible, we can go ahead and pivot
         
         put 0 into sFootPivotCount // Register than no feet have yet moved
         put the long ID of btn "pivot" into tPivot

         aeLockMoves
         aeMoveTo the long id of btn "foot1",tFoot1x,tFoot1y,sPivotAnimateSpeed,"overshoot"
         aeMoveTo the long id of btn "foot2",tFoot2x,tFoot2y,sPivotAnimateSpeed,"overshoot"
         aeMoveTo the long id of btn "foot3",tFoot3x,tFoot3y,sPivotAnimateSpeed,"overshoot"
         aeUnlockMoves
         
         send "incrMoves" to this card in sPivotAnimateSpeed milliseconds // Increment moves counter
         
      end if
      
   end if
   
end pivot

## Called by AE on completion of animation

on aeMoveDone
   
   if sCurrentAnimation is "pivot" and sFootPivotCount < 2 then // If we're pivoting but all three feet have not yet be repositioned
      put sFootPivotCount + 1 into sFootPivotCount // Increment foot count
   else if sCurrentAnimation is "pivot" and sFootPivotCount is 2 then // If the pivot is complete
      repositionPivot
   else if sCurrentAnimation is "jump" then // If we've just completed a jump
      repositionPivot
   end if
   
end aeMoveDone

function detectCollision 
   put false into tCollide
   repeat with tControl = 1 to the number of controls of current card // Cycle through card's controls
      if the short name of control tControl is "block" then // If this one's a block
         put the loc of control tControl into tBlockLoc // Get its location
         if tBlockLoc is the loc of btn "shadowFoot1" or tBlockLoc is the loc of btn "shadowFoot2" or tBlockLoc is the loc of btn "shadowFoot3" then // If the loc matches one of the shadow feet
            put true into tCollide // There has been a collision
            exit repeat
         end if
      end if
   end repeat
   
   return tCollide
end detectCollision

// Nudges feet on disallowed pivot attempt
on nudge pFoot, pFootX, pFootY, pFootCurrPosX, pFootCurrPosY // Foot, attempted X, attempted Y, pre-nudge X, pre-nudge Y
   if item 1 of the loc of btn pFoot < pFootX then
      move btn pFoot to pFootCurrPosX + 4, pFootCurrPosY in 50 milliseconds without waiting // Nudge right
   else if item 1 of the loc of btn pFoot > pFootX then
      move btn pFoot to pFootCurrPosX - 4, pFootCurrPosY in 50 milliseconds without waiting // Nudge left
   else if item 2 of the loc of btn pFoot < pFootY then
      move btn pFoot to pFootCurrPosX, pFootCurrPosY + 4 in 50 milliseconds without waiting // Nudge down
   else if item 2 of the loc of btn pFoot > pFootY then
      move btn pFoot to pFootCurrPosX, pFootCurrPosY - 4 in 50 milliseconds without waiting // Nudge up
   end if
   
   send "nudgeBack pFoot, pFootCurrPosX, pFootCurrPosY" to btn pFoot in 275 milliseconds // Call nudgeBack() after a short interval
end nudge

// Nudges feet back to original position after disallowed pivot attempt
on nudgeBack pTarget,pX,pY,pTime
   move btn pTarget to pX,pY in 50 milliseconds without waiting
end nudgeBack

on jumpBack pTarget,pX,pY,pEffect
   aeMoveTo the long id of btn pTarget,pX,pY,sJumpAnimateSpeed,pEffect
end jumpBack

on levelWin
   
   stopGame
   
   put "You've won the level!" into tWinMsg
   
   ## Check for high score
   
   put false into tNewHighScore      
   put the cHighScores[gLevel] of this stack into tCurrentHighScore // Get previous high score
   
   if sMovesCounter < tCurrentHighScore then // If we've completed the level in fewer moves than our previous attempts
      put true into tNewHighScore // Flag that this is a new high score
   end if
   
   if tNewHighScore then // If it's a new high score
      set the cHighScores[gLevel] of this stack to sMovesCounter // Set the high score for this level to current value of moves counter
      put tWinMsg & " You also also achieved a new personal best for this level of " & sMovesCounter & " moves!" into tWinMsg
   end if
   
   answer tWinMsg
   
end levelWin

on updateScreen
   
   if sGameRunning is true then
      
      // If the foot is a mid-transit location, switch on the animation flag
      if sFoot1Loc["x"] <> item 1 of the loc of button "foot1" or sFoot1Loc["y"] <> item 2 of the loc of button "foot1" or sFoot2Loc["x"] <> item 1 of the loc of button "foot2" or sFoot2Loc["y"] <> item 2 of the loc of button "foot2" or sFoot3Loc["x"] <> item 1 of the loc of button "foot3" or sFoot3Loc["y"] <> item 2 of the loc of button "foot3" then
         put true into sAnimating
      else
         put false into sAnimating
      end if
      
      if not sAnimating then 
         
         ## Check for win         
         
         // Reset check for feet landing correctly
         put false into tFoot1LandSuccess
         put false into tFoot2LandSuccess
         put false into tFoot3LandSuccess
         
         // Foot 1       
         repeat for each element tLoc in sFootLanding1Locs // Get the locs at which foot is able to land for level to be won
            if item 1 of the loc of button "foot1" is item 1 of tLoc and item 2 of the loc of button "foot1" is item 2 of tLoc then // If the X and Y coords of the foot match one of the array items
               put true into tFoot1LandSuccess
            end if
         end repeat
         
         // Foot 2       
         repeat for each element tLoc in sFootLanding2Locs 
            if item 1 of the loc of button "foot2" is item 1 of tLoc and item 2 of the loc of button "foot2" is item 2 of tLoc then
               put true into tFoot2LandSuccess
            end if
         end repeat
         
         // Foot 3   
         repeat for each element tLoc in sFootLanding3Locs 
            if item 1 of the loc of button "foot3" is item 1 of tLoc and item 2 of the loc of button "foot3" is item 2 of tLoc then
               put true into tFoot3LandSuccess
            end if
         end repeat
         
         if tFoot1LandSuccess and tFoot2LandSuccess and tFoot3LandSuccess then
            levelWin
         end if
         
      end if
      
   end if
   
end updateScreen

