local sStartUpdateTime
local sUpdateMessageId
local sCellWidth
local sFoot1Loc
local sFoot2Loc
local sFoot3Loc
local sPivotLoc

local sFootPivotCount // Keep track of how many feet have moved in pivot move (animation happens asynchronously and AE only offers a single callback out of the box)

local sFootLanding1Locs // Array of the loc(s) that foot 1 needs to be at to win
local sFootLanding2Locs
local sFootLanding3Locs

local sLevelProperties
local sGameRunning

local sCheckingForWin

local sMovesCounter

global gTouchStartLoc
global gScale
global gTouchedFoot

local sLastLevelCompleted

local sTime

local sJumpAnimateSpeed
local sPivotAnimateSpeed
local sCurrentAnimation // Pivot or jump
local sCollision

## Make sure background animation pending messages are cleared

on cancelPendingMessages   
   
   repeat for each line aLine in the pendingMessages
      if aLine contains "animateBackground" or aLine contains "aeGeneral" or aLine contains "aeMoveTo" then // Item 1 is the message ID
         cancel item 1 of aLine
      end if
   end repeat
   
end cancelPendingMessages

on preOpenStack
   
   set the accelleratedRendering of this stack to true
   set the defaultFolder to specialFolderPath("documents") // Where we write files to (good for iOS and Mac OS X)
   start using stack "Helper"
   
   if the environment is "mobile" then

      set the rect of this stack to the screenrect // Resize the stack
      
      if iphoneDeviceScale() is "2" then // Returns 2 on a retina display, 1 otherwise
         put 2 into gScale
         iphoneUseDeviceResolution true, true // Sets whether the full resolution of high-resolution devices is to be used
      end if
      
   end if
   
end preOpenStack

on openStack
   
   if "animationEngine" is not among the lines of the stacksInUse then
      start using stack "animationEngine"
   end if
   
   aeSetFrameRate 50 // Set the Animation Engine frame rate
   
   if there is a file "moves.txt" then
      put URL ("file:moves.txt") into tTotalMoves // Get total moves used from file
      set the cTotalMovesRemaining of the current stack to tTotalMoves // Update stack custom property
   else
      set the cTotalMovesRemaining of the current stack to 10000 // If no file, then put to 10000
   end if
   
   put the cTotalMovesRemaining of the current stack into fld "moves_remaining" of cd "settings"
   
   retrieveHighScores   
   
end openStack

on closeStack
   
   put the cTotalMovesRemaining of the current stack into URL ("file:moves.txt") // Store number of moves remaining   
   saveHighScores
   
end closeStack

on saveHighScores
   
   // Get high scores custom property as an array
   put the customProperties["cHighScores"] of the current stack into tHighScores
   
   // Cycle through the array and format for saving to file
   repeat for each line tKey in the keys of tHighScores
      put tKey & ":" & tHighScores[tKey] & return after tArrayContents
   end repeat
   
   put tArrayContents into URL ("file:highscores.txt") // Save to file
   
end saveHighScores

## Read high scores from file
on retrieveHighScores
   
   if there is a file "highscores.txt" then      
      put URL ("file:highscores.txt") into tHighScores // Get text file   
      split tHighScores by return and ":" // Split into array   
      set the customProperties["cHighScores"] of this stack to tHighScores // Set the array to value of cHighScores custom property
   end if   
   
end retrieveHighScores

## Level launch controller

on launchLevel
      
   configureLevelCard
   
   go cd "level"
   
   positionLevelElements
   
   setupLevel
   startGame
   
end launchLevel

## Copies controls from relevant level template to the actual level card

on configureLevelCard

   put "level" & the cCurrentLevel of this stack into tCurrentLevel // Get level name
   put the customProperties[tCurrentLevel] of this stack into tLevelProperties // Get level's custom properties
   put tLevelProperties into sLevelProperties // Make level properties available to whole script
   put tLevelProperties["cLevelTemplate"] into tTemplateName
   deleteControlsFromCard "level" // Delete any existing controls from the "level" card
 
   repeat with tControl = 1 to the number of controls in cd tLevelProperties["cLevelTemplate"] // Go through all controls in template card
      copy control tControl of card tTemplateName to card "level" // Copy them over to the level
   end repeat

   ## Populate src element buttons with images relevant to this level
   
   put tLevelProperties["cFootImageGrps"] into tFootImageGrps // Get image groups used for each foot
   split tFootImageGrps by return and ":" // Split into array
   
   repeat for each line tKey in the keys of tFootImageGrps
      put tFootImageGrps[tKey] & "@2x" into tFootImage // Concatenate foot image name
      put "foot" & tKey & "_src" into tButtonName // Concatenate button name      
      set the cAnim of btn tButtonName of cd "level" to the cAnim of grp tFootImageGrps[tKey] of the cd "elements" // Apply animation image list (from foot group custom properties) to the foot
      setControlIcon tButtonName, "level", tFootImage, "elements" // Set the icon
      
      put tFootImageGrps[tKey] & "_landing@2x" into tFootLandingImage // Concatenate foot landing image name
      put "landing" & tKey & "_src" into tButtonName // Concatenate button name
      setControlIcon tButtonName, "level", tFootLandingImage, "elements" // Set the icon
      
   end repeat
   
end configureLevelCard

## Position the relevant elements (to cater for different screen sizes)

on positionLevelElements
   
   set the loc of btn "grid" of the cd "level" to the loc of cd "level" // Center game grid
   
   // Position moves counter
   set the left of fld "moves" of the cd "level" to 0
   set the left of btn "moves_value" of the cd "level" to the right of fld "moves" of the cd "level"
   set the top of fld "moves" of the cd "level" to 0
   set the top of btn "moves_value" of the cd "level" to 0
   
   // Position "Previous Best" fields
   set the right of btn "previous_best_value" of the cd "level" to the width of the cd "level"
   set the right of fld "previous_best" of the cd "level" to the left of btn "previous_best_value" of the cd "level"   
   set the top of fld "previous_best" of the cd "level" to 0
   set the top of btn "previous_best_value" of the cd "level" to 0
   
   // Position "Exit" button
   set the bottom of the btn "stop" of the cd "level" to the height of the cd "level"
   set the right of the btn "stop" of the cd "level" to the width of the cd "level"
   
   if the environment is "mobile" then
      
      set the loc of btn "bg" of the cd "level" to the loc of the cd "level"
      set the loc of btn "grid" of the cd "level" to the loc of the cd "level"
      
   end if
   
end positionLevelElements

## Level setup

on setupLevel
   
   put the width of btn "grid" / 8 into sCellWidth // Get width of each circular 'cell'
   put sCellWidth / 2 + the left of btn "grid" into tX // Work out starting point on X axis
   put sCellWidth / 2 + the top of btn "grid" into tY // And the Y
   
   put sLevelProperties["cElementPlacement"] into tElPlacement // Get placement grid
   
   repeat for each line l in tElPlacement -- Cycle through each line
      
      repeat for each item el in l -- Cycle through each cell
         
         ## Check button type
         if el is 4 then -- Block
            clone button "block_src"
            set the name of it to "block"
         else if el is 1 then -- Foot 1
            clone button "foot1_src"
            set the name of it to "foot1"
            set the class of it to "foot"
         else if el is 2 then -- Foot 2
            clone button "foot2_src"
            set the name of it to "foot2"
            set the class of it to "foot"
         else if el is 3 then -- Foot 3
            clone button "foot3_src"
            set the name of it to "foot3"
            set the class of it to "foot"
         else if el is 5 then -- Landing 1
            clone button "landing1_src"
            set the name of it to "landing1"
            set the class of it to "landing"
         else if el is 6 then -- Landing 2
            clone button "landing2_src"
            set the name of it to "landing2"
            set the class of it to "landing"
         else if el is 7 then -- Landing 3
            clone button "landing3_src"
            set the name of it to "landing3"
            set the class of it to "landing"
         else if el is 8 then -- Pivot
            clone button "pivot_src"
            set the name of it to "pivot"
            set the visible of it to false
         end if
         
         if el is not 0 then
            set the loc of the last button to tX,tY -- Place button on grid
         end if
         
         put tX + sCellWidth into tX -- Next cell
         
      end repeat 
      
      put sCellWidth / 2 + the left of button "grid" into tX -- Back to beginning of row
      put tY + sCellWidth into tY -- Next row
      
   end repeat   
   
   // Bring sprite to top
   set the layer of btn "foot3" to top
   set the layer of btn "foot2" to top
   set the layer of btn "foot1" to top
   set the layer of btn "pivot" to top
   
   ## Store the starting positions of the feet
   
   put item 1 of the loc of btn "foot1" into sFoot1Loc["x"] // X
   put item 2 of the loc of btn "foot1" into sFoot1Loc["y"] // Y
   
   put item 1 of the loc of btn "foot2" into sFoot2Loc["x"]
   put item 2 of the loc of btn "foot2" into sFoot2Loc["y"]
   
   put item 1 of the loc of btn "foot3" into sFoot3Loc["x"]
   put item 2 of the loc of btn "foot3" into sFoot3Loc["y"]   
   
   ## Store pivot position
   
   put the loc of btn "pivot" into sPivotLoc
   
   ## Set various level values
   
   put false into sChangeInFootPos
   put 500 into sJumpAnimateSpeed // Speed in ms jump
   put 340 into sPivotAnimateSpeed // Speed in ms jump
   put 0 into sMovesCounter // Reset move counter
   put false into sCollision // Set collision flag to false
   put empty into sFootLandingLocs // Empty target foot location array
   set the label of button "moves_value" to sMovesCounter // Amend moves counter
   put false into sCheckingForWin // Prevents further moves while code checks to see whether use has positioned feet at the target locations
   put empty into sCurrentAnimation
   put empty into sTouchStartLoc
   put empty into gTouchStartLoc
   
   // Clear landing location arrays
   put empty into sFootLanding1Locs
   put empty into sFootLanding2Locs
   put empty into sFootLanding3Locs
   
   ## Calculate landing locs
   
   // Get the icon ID of each foot
   put the icon of btn "foot1" into tFoot1Icon
   put the icon of btn "foot2" into tFoot2Icon
   put the icon of btn "foot3" into tFoot3Icon
   
   // Get the locs of the three landing spots
   put the loc of btn "landing1" into tLanding1Loc
   put the loc of btn "landing2" into tLanding2Loc
   put the loc of btn "landing3" into tLanding3Loc
   
   if tFoot1Icon is tFoot2Icon and tFoot1Icon is tFoot3Icon then // If all feet use the same icon      
      
      // Create temp array
      put tLanding1Loc into tArray[1]
      put tLanding2Loc into tArray[2]
      put tLanding3Loc into tArray[3]
      
      // Put the array into the landing locs array
      put tArray into sFootLanding1Locs
      put tArray into sFootLanding2Locs
      put tArray into sFootLanding3Locs
      
   else if tFoot1Icon is tFoot2Icon and tFoot1Icon is not tFoot3Icon then // If feet 1 and 2 are the same
      
      put tLanding1Loc into tArray[1]
      put tLanding2Loc into tArray[2]
      
      put tArray into sFootLanding1Locs
      put tArray into sFootLanding2Locs
      
      put tLanding3Loc into sFootLanding3Locs[1]
      
   else if tFoot2Icon is tFoot3Icon and tFoot1Icon is not tFoot3Icon then // If feet 2 and 3 are the same
      
      put tLanding2Loc into tArray[1]
      put tLanding3Loc into tArray[2]
      
      put tArray into sFootLanding2Locs
      put tArray into sFootLanding3Locs
      
      put tLanding1Loc into sFootLanding1Locs[1]
      
   else // If all feet have different icons
      
      put tLanding1Loc into sFootLanding1Locs[1]
      put tLanding2Loc into sFootLanding2Locs[1]
      put tLanding3Loc into sFootLanding3Locs[1]
      
   end if
   
   put the cTotalMovesRemaining of the current stack into fld "moves_remaining" of cd "settings"
   set the label of button "time_value" to 0
   
end setupLevel

// Hide the sprite

on hideSprite
   set the vis of button "foot1" to false
   set the vis of button "foot2" to false
   set the vis of button "foot3" to false
end hideSprite

// Flash the sprite

on aeWrapper pAEFunc, pMilliSecs
   
   if pAEFunc is "fadeIn" then
      aeLockMoves
      aeFadeIn the long id of btn "foot1",pMilliSecs
      aeFadeIn the long id of btn "foot2",pMilliSecs
      aeFadeIn the long id of btn "foot3",pMilliSecs
      aeUnlockMoves
   end if
   
   if pAEFunc is "fadeOut" then
      aeLockMoves
      aeFadeOut the long id of btn "foot1",pMilliSecs
      aeFadeOut the long id of btn "foot2",pMilliSecs
      aeFadeOut the long id of btn "foot3",pMilliSecs
      aeUnlockMoves
   end if
   
end aeWrapper

on flashSprite
   
   put 200 into flashSpeed
   
   // Flash pivot
   put the long ID of btn "pivot" into tPivot
   send "aefadeIn tPivot, flashSpeed" to me in 750 millisecs
   
   // Flash feet   
   send "aeWrapper fadeIn, flashSpeed" to me in 450 millisecs
   send "aeWrapper fadeIn, flashSpeed" to me in 750 millisecs
   
end flashSprite

on test
   
   aeStopMoving the long ID of btn "bg" of the cd "level"
   cancelPendingMessages
   
end test

on clearLevel
   
   aeStopMoving the long ID of btn "bg" of the cd "level" // Stop background moving
   
   // Reset variables and custom properties
   put "null" into sCurrentAnimation
   set the pJumpTriggered of the cd "level" to false
   
   // Delete level objects from card
   put the number of buttons of this card into tCount
   repeat with x = tCount down to 1
        if the class of button x of this card is "foot" or the class of button x of this card is "landing" or the class of button x of this card is "shadowFoot" or the short name of button x of this card is "block" or the short name of button x of this card is "pivot" then
             delete button x of this card
        end if
   end repeat
   
   cancelPendingMessages // Cancel any pending messages (e.g. background image move)
   
end clearLevel   
   
on animateBackground
   
   put "bg" into tBackground
   put "level" into tCard
   
   //send "aeMoveTo the long id of btn tBackground, the width of this card, item 2 of this loc of this card, 7000" to me in 1 millisec // To left 
   send "aeMoveTo the long id of btn tBackground of the card tCard, 0, item 2 of the loc of this card, 20000" to me in 1 millisecs // To right
   send "aeMoveTo the long id of btn tBackground of the card tCard, the width of this card, item 2 of the loc of this card, 20000" to me in 20100 millisecs // To left
   
   if sGameRunning then
      
      send "animateBackground" to me in 40200 millisecs // Repeat animation
      
   end if
   
end animateBackground   
   
on startGame
   
   flashSprite
   repositionPivot
   
   put true into sGameRunning
   
   put the loc of this card into tCardLoc
   
   set the loc of btn "bg" to the width of this card, item 2 of this loc of this card // Background button to left
   animateBackground
   
end startGame

on stopGame
   
   put false into sGameRunning
   
end stopGame

on startTimer
   
   put the seconds into sTime
   goTimer
   
end startTimer

on goTimer
   
   // Stop time when game stops running
   if not sGameRunning then
      exit to top
   end if
   
   set the label of btn "time_value" to 0 + (the seconds - sTime)
   send "goTimer" to me in 1 millisec
   
end goTimer

on incrMoves
   
   set the label of button "moves_value" to sMovesCounter // Amend moves counter
   
   set the cTotalMovesRemaining of the current stack to the cTotalMovesRemaining of the current stack - 1 // Total moves--

   put the cTotalMovesRemaining of the current stack into fld "moves_remaining" of cd "settings" // Amend total moves counter
    
end incrMoves

on goJump pX, pY, pPivotX, pPivotY, pFootShortName, pDirection
   
   put false into tBoundaryHit
   
   // Get coords of previous foot loc
   put the loc of button pFootShortName into tPreMoveFootPos
   put item 1 of tPreMoveFootPos into tFootPrevX
   put item 2 of tPreMoveFootPos into tFootPrevY
   
   // Get coords of grid boundary
   put the top of button "grid" into tGridTop
   put the bottom of button "grid" into tGridBottom
   put the left of button "grid" into tGridLeft
   put the right of button "grid" into tGridRight
   
   set the layer of btn pFootShortName to top // Bring foot to front   
   
   if pY < tGridTop or pY > tGridBottom or pX < tGridLeft or pX > tGridRight then // If game area boundary will be hit
      
      put true into tBoundaryHit
      
   end if  
   
   put "inOut" into tJumpEffect // Default jump easing effect
   put sJumpAnimateSpeed into tJumpAnimateSpeed
   
   // Detect collision with block
   set the loc of btn "shadowFoot1" to pX,pY // Set position of a shadow foot to check for imminent collisions  
   put detectCollision() into tJumpCollide
   
   send "hidePivot 100" to me in 1 millisecs // Fade out pivot   
   animateFoot pFootShortName, 12 // Start foot 'jump' animation
   
   if tJumpCollide and not tBoundaryHit then // If the foot will jump onto a block
      
      put "jumpFail" into sCurrentAnimation
      
      aeLockMoves
      aeMoveTo the long id of btn pFootShortName,pX,pY,sJumpAnimateSpeed,tJumpEffect
      aeUnlockMoves
      
      send "animateFoot pFootShortName, 18" to me in sJumpAnimateSpeed + 400 millisecs // Start foot 'jump' animation
      send "jumpBack pFootShortName, tFootPrevX, tFootPrevY, inOut" to btn pFootShortName in sJumpAnimateSpeed + 400 millisecs // Call jumpBack() after a short interval
      send "showPivot 150" to me in sJumpAnimateSpeed + 700 millisecs // Fade pivot back in
      
   else if tBoundaryHit then // If boundary will be hit
      
      if pDirection is "N" then
         put item 1 of the loc of btn pFootShortName into pX // X pos will be the same
         put the top of btn "grid" + (sCellWidth / 2) into pY // Jump to top of grid
      else if pDirection is "E" then
         put the right of btn "grid" - (sCellWidth / 2) into pX
         put item 2 of the loc of btn pFootShortName into pY
      else if pDirection is "S" then
         put item 1 of the loc of btn pFootShortName into pX
         put the bottom of btn "grid" - (sCellWidth / 2) into pY
      else if pDirection is "W" then
         put the left of btn "grid" + (sCellWidth / 2) into pX
         put item 2 of the loc of btn pFootShortName into pY
      else // For other jump directions, we'll move to the triangle centroid
         
         // Position shadow feet in what would be the post-jump positions (pFootShortName is, of course, out of bounds)
         if pFootShortName is "foot1" then
            set the loc of btn "shadowFoot1" to pX,pY
            set the loc of btn "shadowFoot2" to the loc of btn "foot2"
            set the loc of btn "shadowFoot3" to the loc of btn "foot3"
         else if pFootShortName is "foot2" then
            set the loc of btn "shadowFoot2" to pX,pY
            set the loc of btn "shadowFoot1" to the loc of btn "foot1"
            set the loc of btn "shadowFoot3" to the loc of btn "foot3"
         else if pFootShortName is "foot3" then
            set the loc of btn "shadowFoot3" to pX,pY
            set the loc of btn "shadowFoot1" to the loc of btn "foot1"
            set the loc of btn "shadowFoot2" to the loc of btn "foot2"
         end if
         
         // Get coords of the shadow feet
         put item 1 of the loc of btn "shadowFoot1" into x1
         put item 1 of the loc of btn "shadowFoot2" into x2
         put item 1 of the loc of btn "shadowFoot3" into x3
         
         put item 2 of the loc of btn "shadowFoot1" into y1
         put item 2 of the loc of btn "shadowFoot2" into y2
         put item 2 of the loc of btn "shadowFoot3" into y3
         
         put getTriangleCentroid(x1, x2, x3, y1, y2, y3) into tCentroid // Get centroid
         
         // Modify coord parameters to centroid coords
         put round(item 1 of tCentroid) into pX
         put round(item 2 of tCentroid) into pY
         
      end if
      
      put round(sJumpAnimateSpeed / 1.5) into tJumpAnimateSpeed
      
      // Set timer for jump back to where the foot was
      send "jumpBack pFootShortName, tFootPrevX, tFootPrevY, bounce" to me in (tJumpAnimateSpeed + 100) milliseconds // Jump back after short wait
      send "showPivot 150" to me in (sJumpAnimateSpeed + 250) millisecs // Show the pivot
      
   end if
   
   if not tJumpCollide then
      
      // Do the jump
      aeLockMoves
      aeMoveTo the long id of btn pFootShortName,pX,pY,tJumpAnimateSpeed,tJumpEffect
      aeUnlockMoves
      
   end if
   
   
   
   if not tBoundaryHit and not tJumpCollide then // If a boundary hasn't been hit, or the foot hasn't jumped onto a block
      
      send "showPivot 150" to me in sJumpAnimateSpeed millisecs
      
      put sMovesCounter + 1 into sMovesCounter // sMovesCounter++
      send "incrMoves" to this card in sJumpAnimateSpeed milliseconds // Increment moves counter
      
      if pFootShortName is "foot1" then // Update script-level loc for relevant foot
         put pX into sFoot1Loc["x"]
         put pY into sFoot1Loc["y"]
      else if pFootShortName is "foot2" then
         put pX into sFoot2Loc["x"]
         put pY into sFoot2Loc["y"]
      else if pFootShortName is "foot3" then
         put pX into sFoot3Loc["x"]
         put pY into sFoot3Loc["y"]
      end if
   end if
   
end goJump

## Fades out pivot

on hidePivot pSpeed
   
   put the long ID of btn "pivot" into tPivot      
   aeFadeOut tPivot, pSpeed
   
end hidePivot

## Fades in pivot and puts to top layer

on showPivot pSpeed
   
   put the long ID of btn "pivot" into tPivot   
   set the layer of tPivot to top
   aePivotFadeIn tPivot, pSpeed
   
end showPivot

## Animates lift and drop of foot

on goAnimate pFootShortName, imageID
   set the icon of btn pFootShortName to imageID
end goAnimate

## Control animation for lift and drop of foot

on animateFoot pFootShortName, pFrameRateFactor
   
   put the imgGrp of btn pFootShortName into tImgGrpID // Get the ID of the image group which corresponds with this foot
   put the cAnim of btn pFootShortName into tAnimImages // Get the anim custom property of the group (in the "elements" card). This lists the images which will be used in the animation
   
   put round(sJumpAnimateSpeed / pFrameRateFactor) into tAnimInc // Calculate a 'frame rate'
   put 1 into tMultiplier // So animation frames change at right moment
   
   // Do the animation
   repeat for each line tImgID in tAnimImages
      send "goAnimate pFootShortName, tImgID" to btn pFootShortName in tAnimInc * tMultiplier milliseconds
      put tMultiplier + 1 into tMultiplier
   end repeat
   
end animateFoot

on repositionPivot
   
   // Get angles of foot one to other two feet
   put the loc of btn "foot1" into tFoot1
   put the loc of btn "foot2" into tFoot2
   put the loc of btn "foot3" into tFoot3
   
   put getAngleBetweenPoints(tFoot1, tFoot2) into tAngle12
   put getAngleBetweenPoints(tFoot1, tFoot3) into tAngle13
   
   put round(sCellWidth / 6) into tPivotShift // The pivot will be moved by slightly more than the cell width
   
   ## For clockwise arrangement 1, 2, 3
   
   if tAngle12 is 63 and tAngle13 is 117 then // Position 1
      put item 1 of tFoot1 into tPivotX
      put item 2 of tFoot1 + sCellWidth + tPivotShift into tPivotY
      
   else if tAngle12 is 90 and tAngle13 is 153 then // Position 2
      put item 2 of tFoot3 into tPivotY
      put item 1 of tFoot3 + sCellWidth + tPivotShift into tPivotX
      
   else if tAngle12 is 117 and tAngle13 is 180 then // Position 3
      put item 1 of tFoot2 into tPivotX
      put item 2 of tFoot2 - sCellWidth - tPivotShift into tPivotY
      
   else if tAngle12 is 153 and tAngle13 is -153 then // Position 4
      put item 2 of tFoot1 into tPivotY
      put item 1 of tFoot1 - sCellWidth - tPivotShift into tPivotX
      
   else if tAngle12 is 180 and tAngle13 is -117 then // Position 5
      put item 1 of tFoot3 into tPivotX
      put item 2 of tFoot3 + sCellWidth + tPivotShift into tPivotY
      
   else if tAngle12 is -153 and tAngle13 is -90 then // Position 6
      put item 2 of tFoot2 into tPivotY
      put item 1 of tFoot2 + sCellWidth + tPivotShift into tPivotX
      
   else if tAngle12 is -117 and tAngle13 is -63 then // Position 7
      put item 1 of tFoot1 into tPivotX
      put item 2 of tFoot1 - sCellWidth - tPivotShift into tPivotY
      
   else if tAngle12 is -90 and tAngle13 is -27 then // Position 8
      put item 2 of tFoot3 into tPivotY
      put item 1 of tFoot3 - sCellWidth - tPivotShift into tPivotX
      
   else if tAngle12 is -63 and tAngle13 is 0 then // Position 9
      put item 1 of tFoot2 into tPivotX
      put item 2 of tFoot2 + sCellWidth + tPivotShift into tPivotY
      
   else if tAngle12 is -27 and tAngle13 is 27 then // Position 10
      put item 2 of tFoot1 into tPivotY
      put item 1 of tFoot1 + sCellWidth + tPivotShift into tPivotX
      
   else if tAngle12 is 0 and tAngle13 is 63 then // Position 11
      put item 1 of tFoot3 into tPivotX
      put item 2 of tFoot3 - sCellWidth - tPivotShift into tPivotY
      
   else if tAngle12 is 27 and tAngle13 is 90 then // Position 12
      put item 2 of tFoot2 into tPivotY
      put item 1 of tFoot2 - sCellWidth - tPivotShift into tPivotX
      
   else if tAngle13 is 63 and tAngle12 is 117 then // Position 1 (clockwise 1, 3, 2)         
      put item 1 of tFoot1 into tPivotX
      put item 2 of tFoot1 + sCellWidth + tPivotShift into tPivotY
      
   else if tAngle13 is 90 and tAngle12 is 153 then // Position 2
      put item 2 of tFoot2 into tPivotY
      put item 1 of tFoot2 + sCellWidth + tPivotShift into tPivotX
      
   else if tAngle13 is 117 and tAngle12 is 180 then // Position 3
      put item 1 of tFoot3 into tPivotX
      put item 2 of tFoot3 - sCellWidth - tPivotShift into tPivotY
      
   else if tAngle13 is 153 and tAngle12 is -153 then // Position 4
      put item 2 of tFoot1 into tPivotY
      put item 1 of tFoot1 - sCellWidth - tPivotShift into tPivotX
      
   else if tAngle13 is 180 and tAngle12 is -117 then // Position 5
      put item 1 of tFoot2 into tPivotX
      put item 2 of tFoot2 + sCellWidth + tPivotShift into tPivotY
      
   else if tAngle13 is -153 and tAngle12 is -90 then // Position 6
      put item 2 of tFoot3 into tPivotY
      put item 1 of tFoot3 + sCellWidth + tPivotShift into tPivotX
      
   else if tAngle13 is -117 and tAngle12 is -63 then // Position 7
      put item 1 of tFoot1 into tPivotX
      put item 2 of tFoot1 - sCellWidth - tPivotShift into tPivotY
      
   else if tAngle13 is -90 and tAngle12 is -27 then // Position 8
      put item 2 of tFoot2 into tPivotY
      put item 1 of tFoot2 - sCellWidth - tPivotShift into tPivotX
      
   else if tAngle13 is -63 and tAngle12 is 0 then // Position 9
      put item 1 of tFoot3 into tPivotX
      put item 2 of tFoot3 + sCellWidth + tPivotShift into tPivotY
      
   else if tAngle13 is -27 and tAngle12 is 27 then // Position 10
      put item 2 of tFoot1 into tPivotY
      put item 1 of tFoot1 + sCellWidth + tPivotShift into tPivotX
      
   else if tAngle13 is 0 and tAngle12 is 63 then // Position 11
      put item 1 of tFoot2 into tPivotX
      put item 2 of tFoot2 - sCellWidth - tPivotShift into tPivotY
      
   else if tAngle13 is 27 and tAngle12 is 90 then // Position 12
      put item 2 of tFoot3 into tPivotY
      put item 1 of tFoot3 - sCellWidth - tPivotShift into tPivotX
   else
      // Just a bit of defensive programming for the pivot to stay still if none of the above conditions is met (so tPivotX and tPivotY have a value) 
      put item 1 of the loc of btn "pivot" into tPivotX
      put item 2 of the loc of btn "pivot" into tPivotY
   end if
   
   put tPivotX,tPivotY into sPivotLoc
   
   if the loc of btn "pivot" is not sPivotLoc and sCurrentAnimation is "pivot" then // If the pivot needs to change location after a pivot move
      put the long ID of btn "pivot" into tPivot
      send "aeMoveTo tPivot, item 1 of sPivotLoc, item 2 of sPivotLoc, 200" to me in 1 millisecs
   else if the loc of btn "pivot" is not sPivotLoc and sCurrentAnimation is "jump" then // If the pivot needs to change location after a jump
      set the loc of btn "pivot" to sPivotLoc // Set new loc right away
   else if not sGameRunning then // On card load, before game is running
      set the loc of btn "pivot" to sPivotLoc  
   end if
   
end repositionPivot
   
on jump pFootLoc, pFootShortName
   
   if not sCheckingForWin and not isAnimating() then
      
      resetShowFeet
      
      put "jump" into sCurrentAnimation
      
      put 1 into tFootCount
      // Cycle through all feet
      
      repeat with tControl = 1 to the number of controls in current card // Go through all card controls
         
         if the class of control tControl is "foot" then // If the control is a foot
            
            put "foot" & tFootCount into tFoot
            put the loc of button tFoot into tFootLoc // Get the location of this foot
            
            if tFootLoc is not pFootLoc then // If this isn't the foot we've swiped
               put tFootLoc into tOtherFeetLocs[tFootCount] // Store the coordinates of this foot
            end if
            
            put tFootCount + 1 into tFootCount
         end if
         
      end repeat
      
      put 1 into tCount
      repeat for each element tElement in tOtherFeetLocs // For each of the other two foot locations
         put getAngleBetweenPoints(pFootLoc, tElement) into tAngles[tCount] // Get the angle between the swiped foot and the location of the other foot
         put tCount + 1 into tCount
      end repeat
      
      put item 1 of the loc of button pFootShortName into tX // Get current x pos of the swiped foot
      put item 2 of the loc of button pFootShortName into tY // Get current y pos of the swiped foot
      put item 1 of the loc of button "pivot" into tPivotX // Get current x pos of the pivot
      put item 2 of the loc of button "pivot" into tPivotY // Get current y pos of the pivot      
      
      // Read angles and work out in which direct the foot needs to jump
      if tAngles[1] is -117 and tAngles[2] is -63 or tAngles[2] is -117 and tAngles[1] is -63 then // N    
         put tY - (sCellWidth * 4) into tY // Amend the y pos of swiped foot
         put "N" into tDirection
      else if tAngles[1] is -27 and tAngles[2] is 27 or tAngles[2] is -27 and tAngles[1] is 27 then // E
         put tX + (sCellWidth * 4) into tX
         put "E" into tDirection
      else if tAngles[1] is 117 and tAngles[2] is 63 or tAngles[2] is 117 and tAngles[1] is 63 then // S      
         put tY + (sCellWidth * 4) into tY 
         put "S" into tDirection
      else if tAngles[1] is -153 and tAngles[2] is 153 or tAngles[2] is -153 and tAngles[1] is 153 then // W
         put tX - (sCellWidth * 4) into tX 
         put "W" into tDirection
      else if tAngles[1] is -117 and tAngles[2] is 180 or tAngles[2] is -117 and tAngles[1] is 180 then // NW
         put tY - (sCellWidth * 2) into tY
         put tX - (sCellWidth * 3) into tX
         put "NW" into tDirection
      else if tAngles[1] is -153 and tAngles[2] is -90 or tAngles[2] is -153 and tAngles[1] is -90 then // NNW    
         put tY - (sCellWidth * 3) into tY
         put tX - (sCellWidth * 2) into tX
         put "NNW" into tDirection
      else if tAngles[1] is 0 and tAngles[2] is -63 or tAngles[2] is 0 and tAngles[1] is -63 then // NE
         put tY - (sCellWidth * 2) into tY
         put tX + (sCellWidth * 3) into tX
         put "NE" into tDirection
      else if tAngles[1] is -90 and tAngles[2] is -27 or tAngles[2] is -90 and tAngles[1] is -27 then // NNE    
         put tY - (sCellWidth * 3) into tY
         put tX + (sCellWidth * 2) into tX
         put "NNE" into tDirection
      else if tAngles[1] is 0 and tAngles[2] is 63 or tAngles[2] is 0 and tAngles[1] is 63 then // SE
         put tY + (sCellWidth * 2) into tY
         put tX + (sCellWidth * 3) into tX
         put "SE" into tDirection
      else if tAngles[1] is 90 and tAngles[2] is 27 or tAngles[2] is 90 and tAngles[1] is 27 then // SSE    
         put tY + (sCellWidth * 3) into tY
         put tX + (sCellWidth * 2) into tX
         put "SSE" into tDirection
      else if tAngles[1] is 117 and tAngles[2] is 180 or tAngles[2] is 117 and tAngles[1] is 180 then // SW    
         put tY + (sCellWidth * 2) into tY
         put tX - (sCellWidth * 3) into tX
         put "SW" into tDirection
      else if tAngles[1] is 153 and tAngles[2] is 90 or tAngles[2] is 153 and tAngles[1] is 90 then // SSW    
         put tY + (sCellWidth * 3) into tY
         put tX - (sCellWidth * 2) into tX
         put "SSW" into tDirection
      end if
      
      goJump tX, tY, tPivotX, tPivotY, pFootShortName, tDirection // Do the jump, passing in the new x and y coords of the swiped foot and pivot, and the foot name
   end if
end jump

on resetShowFeet
   set the loc of btn "shadowFoot1" to 0,0
   set the loc of btn "shadowFoot2" to 0,0
   set the loc of btn "shadowFoot3" to 0,0
end resetShowFeet

on pivot
   if not sCheckingForWin and not isAnimating() then // If no element is currently being animated, and we're not checking for a win
      
      resetShowFeet
      
      put "pivot" into sCurrentAnimation
      
      put the loc of btn "foot1" into tLastStationaryPos1
      put the loc of btn "foot2" into tLastStationaryPos2
      put the loc of btn "foot3" into tLastStationaryPos3
      
      split tLastStationaryPos1 by ","
      split tLastStationaryPos2 by ","
      split tLastStationaryPos3 by ","     
      
      put getAngleBetweenPoints(the loc of button "foot1", the loc of button "foot2") into tAngle12
      put getAngleBetweenPoints(the loc of button "foot1", the loc of button "foot3") into tAngle13
      
      ## For clockwise arrangement 1, 2, 3
      
      if tAngle12 is 63 and tAngle13 is 117 then // Position 1
         put sFoot1Loc["x"] + sCellWidth into sFoot1Loc["x"] // Move foot 1 to the right
         put sFoot3Loc["y"] - sCellWidth into sFoot3Loc["y"] // Move foot 3 up
         
      else if tAngle12 is 90 and tAngle13 is 153 then // Position 2
         put sFoot2Loc["x"] - sCellWidth into sFoot2Loc["x"] // Foot 2 left
         put sFoot3Loc["y"] - sCellWidth into sFoot3Loc["y"] // Foot 3 up 
         
      else if tAngle12 is 117 and tAngle13 is 180 then // Position 3
         put sFoot2Loc["x"] - sCellWidth into sFoot2Loc["x"] // Foot 2 left
         put sFoot1Loc["y"] + sCellWidth into sFoot1Loc["y"] // Foot 1 down 
         
      else if tAngle12 is 153 and tAngle13 is -153 then // Position 4
         put sFoot3Loc["x"] + sCellWidth into sFoot3Loc["x"] // Foot 3 right
         put sFoot1Loc["y"] + sCellWidth into sFoot1Loc["y"] // Foot 1 down
         
      else if tAngle12 is 180 and tAngle13 is -117 then // Position 5
         put sFoot3Loc["x"] + sCellWidth into sFoot3Loc["x"] // Foot 3 right
         put sFoot2Loc["y"] - sCellWidth into sFoot2Loc["y"] // Foot 2 up
         
      else if tAngle12 is -153 and tAngle13 is -90 then // Position 6
         put sFoot1Loc["x"] - sCellWidth into sFoot1Loc["x"] // Foot 1 left
         put sFoot2Loc["y"] - sCellWidth into sFoot2Loc["y"] // Foot 2 up
         
      else if tAngle12 is -117 and tAngle13 is -63 then // Position 7
         put sFoot1Loc["x"] - sCellWidth into sFoot1Loc["x"] // Foot 1 left
         put sFoot3Loc["y"] + sCellWidth into sFoot3Loc["y"] // Foot 3 down
         
      else if tAngle12 is -90 and tAngle13 is -27 then // Position 8
         put sFoot2Loc["x"] + sCellWidth into sFoot2Loc["x"] // Foot 2 right
         put sFoot3Loc["y"] + sCellWidth into sFoot3Loc["y"] // Foot 3 down
         
      else if tAngle12 is -63 and tAngle13 is 0 then // Position 9
         put sFoot2Loc["x"] + sCellWidth into sFoot2Loc["x"] // Foot 2 right
         put sFoot1Loc["y"] - sCellWidth into sFoot1Loc["y"] // Foot 1 up
         
      else if tAngle12 is -27 and tAngle13 is 27 then // Position 10
         put sFoot3Loc["x"] - sCellWidth into sFoot3Loc["x"] // Foot 3 left
         put sFoot1Loc["y"] - sCellWidth into sFoot1Loc["y"] // Foot 1 up
         
      else if tAngle12 is 0 and tAngle13 is 63 then // Position 11
         put sFoot3Loc["x"] - sCellWidth into sFoot3Loc["x"] // Foot 3 left
         put sFoot2Loc["y"] + sCellWidth into sFoot2Loc["y"] // Foot 2 down
         
      else if tAngle12 is 27 and tAngle13 is 90 then // Position 12
         put sFoot1Loc["x"] + sCellWidth into sFoot1Loc["x"] // Foot 1 right
         put sFoot2Loc["y"] + sCellWidth into sFoot2Loc["y"] // Foot 2 down        
         
      else if tAngle13 is 63 and tAngle12 is 117 then // Position 1 (clockwise 1, 3, 2)
         put sFoot1Loc["x"] + sCellWidth into sFoot1Loc["x"] // Move foot 1 to the right
         put sFoot2Loc["y"] - sCellWidth into sFoot2Loc["y"] // Move foot 2 up     
         
      else if tAngle13 is 90 and tAngle12 is 153 then // Position 2
         put sFoot3Loc["x"] - sCellWidth into sFoot3Loc["x"] // Foot 3 left
         put sFoot2Loc["y"] - sCellWidth into sFoot2Loc["y"] // Foot 2 up
         
      else if tAngle13 is 117 and tAngle12 is 180 then // Position 3
         put sFoot3Loc["x"] - sCellWidth into sFoot3Loc["x"] // Foot 3 left
         put sFoot1Loc["y"] + sCellWidth into sFoot1Loc["y"] // Foot 1 down 
         
      else if tAngle13 is 153 and tAngle12 is -153 then // Position 4
         put sFoot2Loc["x"] + sCellWidth into sFoot2Loc["x"] // Foot 2 right
         put sFoot1Loc["y"] + sCellWidth into sFoot1Loc["y"] // Foot 1 down
         
      else if tAngle13 is 180 and tAngle12 is -117 then // Position 5
         put sFoot2Loc["x"] + sCellWidth into sFoot2Loc["x"] // Foot 2 right
         put sFoot3Loc["y"] - sCellWidth into sFoot3Loc["y"] // Foot 3 up
         
      else if tAngle13 is -153 and tAngle12 is -90 then // Position 6
         put sFoot1Loc["x"] - sCellWidth into sFoot1Loc["x"] // Foot 1 left
         put sFoot3Loc["y"] - sCellWidth into sFoot3Loc["y"] // Foot 3 up
         
      else if tAngle13 is -117 and tAngle12 is -63 then // Position 7
         put sFoot1Loc["x"] - sCellWidth into sFoot1Loc["x"] // Foot 1 left
         put sFoot2Loc["y"] + sCellWidth into sFoot2Loc["y"] // Foot 2 down
         
      else if tAngle13 is -90 and tAngle12 is -27 then // Position 8
         put sFoot3Loc["x"] + sCellWidth into sFoot3Loc["x"] // Foot 3 right
         put sFoot2Loc["y"] + sCellWidth into sFoot2Loc["y"] // Foot 2 down
         
      else if tAngle13 is -63 and tAngle12 is 0 then // Position 9
         put sFoot3Loc["x"] + sCellWidth into sFoot3Loc["x"] // Foot 3 right
         put sFoot1Loc["y"] - sCellWidth into sFoot1Loc["y"] // Foot 1 up
         
      else if tAngle13 is -27 and tAngle12 is 27 then // Position 10
         put sFoot2Loc["x"] - sCellWidth into sFoot2Loc["x"] // Foot 2 left
         put sFoot1Loc["y"] - sCellWidth into sFoot1Loc["y"] // Foot 1 up
         
      else if tAngle13 is 0 and tAngle12 is 63 then // Position 11
         put sFoot2Loc["x"] - sCellWidth into sFoot2Loc["x"] // Foot 2 left
         put sFoot3Loc["y"] + sCellWidth into sFoot3Loc["y"] // Foot 3 down
         
      else if tAngle13 is 27 and tAngle12 is 90 then // Position 12
         put sFoot1Loc["x"] + sCellWidth into sFoot1Loc["x"] // Foot 1 right
         put sFoot3Loc["y"] + sCellWidth into sFoot3Loc["y"] // Foot 3 down
         
      end if
      
      // Move feet
      put sFoot1Loc["x"] into tFoot1x
      put sFoot1Loc["y"] into tFoot1y
      set the loc of btn "shadowFoot1" to tFoot1x,tFoot1y // Set shadow foot to check for imminent collisions
      
      put sFoot2Loc["x"] into tFoot2x
      put sFoot2Loc["y"] into tFoot2y
      set the loc of btn "shadowFoot2" to tFoot2x,tFoot2y
      
      put sFoot3Loc["x"] into tFoot3x
      put sFoot3Loc["y"] into tFoot3y
      set the loc of btn "shadowFoot3" to tFoot3x,tFoot3y     
      
      if detectCollision() then // If collision
         
         // Put back values of feet positions - we won't be pivoting
         put item 1 of the loc of btn "foot1" into sFoot1Loc["x"]
         put item 2 of the loc of btn "foot1" into sFoot1Loc["y"]
         put item 1 of the loc of btn "foot2" into sFoot2Loc["x"]
         put item 2 of the loc of btn "foot2" into sFoot2Loc["y"]
         put item 1 of the loc of btn "foot3" into sFoot3Loc["x"]
         put item 2 of the loc of btn "foot3" into sFoot3Loc["y"]
         
         // Nudge feet
         nudge "foot1", tFoot1x, tFoot1y, sFoot1Loc["x"], sFoot1Loc["y"]
         nudge "foot2", tFoot2x, tFoot2y, sFoot2Loc["x"], sFoot2Loc["y"]
         nudge "foot3", tFoot3x, tFoot3y, sFoot3Loc["x"], sFoot3Loc["y"]
         
      else if the visible of btn "pivot" then // If no collision and pivot is visible, we can go ahead and pivot
         
         put sMovesCounter + 1 into sMovesCounter // sMovesCounter++
         
         put 0 into sFootPivotCount // Register than no feet have yet moved
         put the long ID of btn "pivot" into tPivot

         aeLockMoves
         aeMoveTo the long id of btn "foot1",tFoot1x,tFoot1y,sPivotAnimateSpeed,"overshoot"
         aeMoveTo the long id of btn "foot2",tFoot2x,tFoot2y,sPivotAnimateSpeed,"overshoot"
         aeMoveTo the long id of btn "foot3",tFoot3x,tFoot3y,sPivotAnimateSpeed,"overshoot"
         aeUnlockMoves
         
         send "incrMoves" to this card in sPivotAnimateSpeed milliseconds // Increment moves counter
         
      end if
      
   end if
   
end pivot

## Called by AE on completion of animation

on aeMoveDone
   
   if sCurrentAnimation is "pivot" and sFootPivotCount < 2 then // If we're pivoting but all three feet have not yet be repositioned
      
      put sFootPivotCount + 1 into sFootPivotCount // Increment foot count
      
   else if sCurrentAnimation is "pivot" and sFootPivotCount is 2 then // If the pivot is complete
      
      repositionPivot
      checkWin
      
   else if sCurrentAnimation is "jump" then // If we've just completed a jump
      
      repositionPivot      
      checkWin
      
   end if
   
end aeMoveDone

function detectCollision 
   put false into tCollide
   repeat with tControl = 1 to the number of controls of current card // Cycle through card's controls
      if the short name of control tControl is "block" then // If this one's a block
         put the loc of control tControl into tBlockLoc // Get its location
         if tBlockLoc is the loc of btn "shadowFoot1" or tBlockLoc is the loc of btn "shadowFoot2" or tBlockLoc is the loc of btn "shadowFoot3" then // If the loc matches one of the shadow feet
            put true into tCollide // There has been a collision
            exit repeat
         end if
      end if
   end repeat
   
   return tCollide
end detectCollision

// Nudges feet on disallowed pivot attempt
on nudge pFoot, pFootX, pFootY, pFootCurrPosX, pFootCurrPosY // Foot, attempted X, attempted Y, pre-nudge X, pre-nudge Y
   
   put round(sCellWidth / 10) into nudgeAmount
   
   if item 1 of the loc of btn pFoot < pFootX then
      move btn pFoot to pFootCurrPosX + nudgeAmount, pFootCurrPosY in 50 milliseconds without waiting // Nudge right
   else if item 1 of the loc of btn pFoot > pFootX then
      move btn pFoot to pFootCurrPosX - nudgeAmount, pFootCurrPosY in 50 milliseconds without waiting // Nudge left
   else if item 2 of the loc of btn pFoot < pFootY then
      move btn pFoot to pFootCurrPosX, pFootCurrPosY + nudgeAmount in 50 milliseconds without waiting // Nudge down
   else if item 2 of the loc of btn pFoot > pFootY then
      move btn pFoot to pFootCurrPosX, pFootCurrPosY - nudgeAmount in 50 milliseconds without waiting // Nudge up
   end if
   
   send "nudgeBack pFoot, pFootCurrPosX, pFootCurrPosY" to btn pFoot in 275 milliseconds // Call nudgeBack() after a short interval
end nudge

// Nudges feet back to original position after disallowed pivot attempt
on nudgeBack pTarget,pX,pY,pTime
   move btn pTarget to pX,pY in 50 milliseconds without waiting
end nudgeBack

on jumpBack pTarget,pX,pY,pEffect
   aeMoveTo the long id of btn pTarget,pX,pY,round(sJumpAnimateSpeed / 1.5),pEffect
end jumpBack

## Check whether feet have landed correctly on respective landing locations

on checkWin
   
   if sGameRunning and not sCheckingForWin and not isAnimating() then
      
      put true into sCheckingForWin // Flag that we're checking for a win
      
      // Reset check for feet landing correctly
      put false into tFoot1LandSuccess
      put false into tFoot2LandSuccess
      put false into tFoot3LandSuccess
      
      // Foot 1       
      repeat for each element tLoc in sFootLanding1Locs // Get the locs at which foot is able to land for level to be won
         if item 1 of the loc of button "foot1" is item 1 of tLoc and item 2 of the loc of button "foot1" is item 2 of tLoc then // If the X and Y coords of the foot match one of the array items
            put true into tFoot1LandSuccess
         end if
      end repeat
      
      // Foot 2       
      repeat for each element tLoc in sFootLanding2Locs 
         if item 1 of the loc of button "foot2" is item 1 of tLoc and item 2 of the loc of button "foot2" is item 2 of tLoc then
            put true into tFoot2LandSuccess
         end if
      end repeat
      
      // Foot 3   
      repeat for each element tLoc in sFootLanding3Locs 
         if item 1 of the loc of button "foot3" is item 1 of tLoc and item 2 of the loc of button "foot3" is item 2 of tLoc then
            put true into tFoot3LandSuccess
         end if
      end repeat
      
      if tFoot1LandSuccess and tFoot2LandSuccess and tFoot3LandSuccess then // If all feet are in the right locations
         levelWin // Run the level win routine
      else
         put false into sCheckingForWin // Flag that we're no longer checking for a win
      end if
      
   end if
   
end checkWin

on levelWin
   
   stopGame   
   flashSprite   
   
   put "You've won the level!" into tWinMsg
   
   ## Check for high score
   
   put false into tNewHighScore
   
   put "level" & the cCurrentLevel of this stack into tLevelName // Get level name
   put the cHighScores[tLevelName] of this stack into tCurrentHighScore // Get previous high score (will be empty on first attempt)
   
   set the cCurrentHighScore of cd "level_win" to tCurrentHighScore // Set current high score property of win card (could be empty)
   set the cNewHighScore of cd "level_win" to empty // Empty new high score property of win card
   set the cBonusPoints of cd "level_win" to empty // Empty bonus points custom property
   
   if tCurrentHighScore is empty or sMovesCounter < tCurrentHighScore then // If we've completed the level in fewer moves than our previous attempts, or this is the first time the level has been won
      
      put true into tNewHighScore // Flag that this is a new high score
      
   end if
   
   if tNewHighScore then // If it's a new high score
      
      put 5 into cBonusPoints // Give 5 bonus points
      
      // Record the current and new high scores for the win card
      set the cCurrentHighScore of cd "level_win" to the cHighScores[tLevelName] of this stack
      set the cNewHighScore of cd "level_win" to sMovesCounter
      
      set the cHighScores[tLevelName] of this stack to sMovesCounter // Set the high score for this level to current value of moves counter
      put "You have achieved a new personal best for this level of " & sMovesCounter & " moves!" into tNewHighScoreMsg
      
   else
      
      put empty into tNewHighScoreMsg
      
   end if
   
   set the cWinMsg of cd "level_win" to tWinMsg // Set the message custom property of the win card
   set the cNewHighScoreMsg of cd "level_win" to tNewHighScoreMsg // Set the new-high-score message of the win card
   send "showWinCard" to me in 1300 millisecs // Show card to tell user they've completed the level
   
   set the cStarRating of cd "level_win" to calculateStarRating() // Get and set star rating
   set the cLevelMoves of cd "level_win" to sMovesCounter // Store moves counter in win card custom property
      
end levelWin

## Calculates the level's star rating based on the level set's cStarRating custom property

function calculateStarRating
   
   put sLevelProperties["cStarRating"] into tStarRating // Get star rating parameters for level
   split tStarRating by return and ":" // Split into array
   
   if sMovesCounter <= tStarRating[3] then
      return 3 // 3-star rating
   else if sMovesCounter > tStarRating[3] and sMovesCounter <= tStarRating[2] then
      return 2 // 2-star rating
   else
      return 1 // 1-star rating
   end if

end calculateStarRating

on showWinCard
   
   clearLevel // Remove onscreen game elements
   go card "level_win" // Go to the success card
   
end showWinCard

function isAnimating
   
   // If the foot is in a mid-transit location, switch on the animation flag
   if sFoot1Loc["x"] <> item 1 of the loc of button "foot1" or sFoot1Loc["y"] <> item 2 of the loc of button "foot1" or sFoot2Loc["x"] <> item 1 of the loc of button "foot2" or sFoot2Loc["y"] <> item 2 of the loc of button "foot2" or sFoot3Loc["x"] <> item 1 of the loc of button "foot3" or sFoot3Loc["y"] <> item 2 of the loc of button "foot3" then
      return true
   else
      return false
   end if
   
end isAnimating

on shutdown
   
   // Save level, prefs, score etc
   
end shutdown
